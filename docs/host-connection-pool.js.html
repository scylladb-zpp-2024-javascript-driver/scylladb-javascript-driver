<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: host-connection-pool.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: host-connection-pool.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
const util = require("util");
const events = require("events");

const Connection = require("./connection");
const utils = require("./utils");
const promiseUtils = require("./promise-utils");
const errors = require("./errors");
const clientOptions = require("./client-options");

// Used to get the index of the connection with less in-flight requests
let connectionIndex = 0;
const connectionIndexOverflow = Math.pow(2, 15);

let defaultOptions;

/**
 * Represents the possible states of the pool.
 * Possible state transitions:
 *  - From initial to closing: The pool must be closed because the host is ignored.
 *  - From initial to shuttingDown: The pool is being shutdown as a result of a client shutdown.
 *  - From closing to initial state: The pool finished closing connections (is now ignored) and it resets to
 *    initial state in case the host is marked as local/remote in the future.
 *  - From closing to shuttingDown (rare): It was marked as ignored, now the client is being shutdown.
 *  - From shuttingDown to shutdown: Finished shutting down, the pool should not be reused.
 * @private
 */
const state = {
    // Initial state: open / opening / ready to be opened
    initial: 0,
    // When the pool is being closed as part of a distance change
    closing: 1,
    // When the pool is being shutdown for good
    shuttingDown: 2,
    // When the pool has being shutdown
    shutDown: 4,
};

/**
 * Represents a pool of connections to a host
 */
class HostConnectionPool extends events.EventEmitter {
    /**
     * Creates a new instance of HostConnectionPool.
     * @param {Host} host
     * @param {Number} protocolVersion Initial protocol version
     * @extends EventEmitter
     */
    constructor(host, protocolVersion) {
        super();
        this._address = host.address;
        this._newConnectionTimeout = null;
        this._state = state.initial;
        this._opening = false;
        this._host = host;
        this.responseCounter = 0;
        this.options = host.options;
        this.protocolVersion = protocolVersion;
        this.coreConnectionsLength = 1;
        /**
         * An immutable array of connections
         * @type {Array.&lt;Connection>}
         */
        this.connections = utils.emptyArray;
        this.setMaxListeners(0);
        this.log = utils.log;
    }

    getInFlight() {
        const length = this.connections.length;
        if (length === 1) {
            return this.connections[0].getInFlight();
        }

        let sum = 0;
        for (let i = 0; i &lt; length; i++) {
            sum += this.connections[i].getInFlight();
        }
        return sum;
    }

    /**
     * Gets the least busy connection from the pool.
     * @param {Connection} [previousConnection] When provided, the pool should attempt to obtain a different connection.
     * @returns {Connection!}
     * @throws {Error}
     * @throws {BusyConnectionError}
     */
    borrowConnection(previousConnection) {
        if (this.connections.length === 0) {
            throw new Error("No connection available");
        }

        const maxRequests = this.options.pooling.maxRequestsPerConnection;
        const c = HostConnectionPool.minInFlight(
            this.connections,
            maxRequests,
            previousConnection,
        );

        if (c.getInFlight() >= maxRequests) {
            throw new errors.BusyConnectionError(
                this._address,
                maxRequests,
                this.connections.length,
            );
        }

        return c;
    }

    /**
     * Gets the connection with the minimum number of in-flight requests.
     * Only checks for 2 connections (round-robin) and gets the one with minimum in-flight requests, as long as
     * the amount of in-flight requests is lower than maxRequests.
     * @param {Array.&lt;Connection>} connections
     * @param {Number} maxRequests
     * @param {Connection} previousConnection When provided, it will attempt to obtain a different connection.
     * @returns {Connection!}
     */
    static minInFlight(connections, maxRequests, previousConnection) {
        const length = connections.length;
        if (length === 1) {
            return connections[0];
        }

        // Use a single index for all hosts as a simplified way to balance the load between connections
        connectionIndex++;
        if (connectionIndex >= connectionIndexOverflow) {
            connectionIndex = 0;
        }

        let current;
        for (
            let index = connectionIndex;
            index &lt; connectionIndex + length;
            index++
        ) {
            current = connections[index % length];
            if (current === previousConnection) {
                // Increment the index and skip
                current = connections[++index % length];
            }

            let next = connections[(index + 1) % length];
            if (next === previousConnection) {
                // Skip
                next = connections[(index + 2) % length];
            }

            if (next.getInFlight() &lt; current.getInFlight()) {
                current = next;
            }

            if (current.getInFlight() &lt; maxRequests) {
                // Check as few connections as possible, as long as the amount of in-flight
                // requests is lower than maxRequests
                break;
            }
        }
        return current;
    }

    /**
     * Creates all the connections in the pool and switches the keyspace of each connection if needed.
     * @param {string} keyspace
     */
    async warmup(keyspace) {
        if (this.connections.length &lt; this.coreConnectionsLength) {
            while (this.connections.length &lt; this.coreConnectionsLength) {
                await this._attemptNewConnection();
            }

            this.log(
                "info",
                `Connection pool to host ${this._address} created with ${this.connections.length} connection(s)`,
            );
        } else {
            this.log(
                "info",
                `Connection pool to host ${this._address} contains ${this.connections.length} connection(s)`,
            );
        }

        if (keyspace) {
            try {
                for (const connection of this.connections) {
                    await connection.changeKeyspace(keyspace);
                }
            } catch (err) {
                // Log it and move on, it could be a momentary schema mismatch failure
                this.log(
                    "warning",
                    `Connection(s) to host ${this._address} could not be switched to keyspace ${keyspace}`,
                );
            }
        }
    }

    /** @returns {Connection} */
    _createConnection() {
        const endpointOrServerName = !this.options.sni
            ? this._address
            : this._host.hostId.toString();

        const c = new Connection(
            endpointOrServerName,
            this.protocolVersion,
            this.options,
        );
        this._addListeners(c);
        return c;
    }

    /** @param {Connection} c */
    _addListeners(c) {
        c.on("responseDequeued", () => this.responseCounter++);

        const self = this;
        function connectionErrorCallback() {
            // The socket is not fully open / can not send heartbeat
            self.remove(c);
        }
        c.on("idleRequestError", connectionErrorCallback);
        c.on("socketClose", connectionErrorCallback);
    }

    addExistingConnection(c) {
        this._addListeners(c);
        // Use a copy of the connections array
        this.connections = this.connections.slice(0);
        this.connections.push(c);
    }

    /**
     * Prevents reconnection timeout from triggering
     */
    clearNewConnectionAttempt() {
        if (!this._newConnectionTimeout) {
            return;
        }
        clearTimeout(this._newConnectionTimeout);
        this._newConnectionTimeout = null;
    }

    /**
     * Tries to open a new connection.
     * If a connection is being opened, it will resolve when the existing open task completes.
     * @returns {Promise&lt;void>}
     */
    async _attemptNewConnection() {
        if (this._opening) {
            // Wait for the event to fire
            return await promiseUtils.fromEvent(this, "open");
        }

        this._opening = true;

        const c = this._createConnection();
        let err;

        try {
            await c.openAsync();
        } catch (e) {
            err = e;
            this.log(
                "warning",
                `Connection to ${this._address} could not be created: ${err}`,
                err,
            );
        }

        if (this.isClosing()) {
            this.log(
                "info",
                `Connection to ${this._address} opened successfully but pool was being closed`,
            );
            err = new Error("Connection closed");
        }

        if (!err) {
            // Append the connection to the pool.
            // Use a copy of the connections array.
            const newConnections = this.connections.slice(0);
            newConnections.push(c);
            this.connections = newConnections;
            this.log(
                "info",
                `Connection to ${this._address} opened successfully`,
            );
        } else {
            promiseUtils.toBackground(c.closeAsync());
        }

        // Notify that creation finished by setting the flag and emitting the event
        this._opening = false;
        this.emit("open", err, c);

        if (err) {
            // Opening failed
            throw err;
        }
    }

    attemptNewConnectionImmediate() {
        const self = this;
        function openConnection() {
            self.clearNewConnectionAttempt();
            self.scheduleNewConnectionAttempt(0);
        }

        if (this._state === state.initial) {
            return openConnection();
        }

        if (this._state === state.closing) {
            return this.once("close", openConnection);
        }
        // In the case the pool its being / has been shutdown for good
        // Do not attempt to create a new connection.
    }

    /**
     * Closes the connection and removes a connection from the pool.
     * @param {Connection} connection
     */
    remove(connection) {
        // locating an object by position in the array is O(n), but normally there should be between 1 to 8 connections.
        const index = this.connections.indexOf(connection);
        if (index &lt; 0) {
            // it was already removed from the connections and it's closing
            return;
        }
        // remove the connection from the pool, using an pool copy
        const newConnections = this.connections.slice(0);
        newConnections.splice(index, 1);
        this.connections = newConnections;
        // close the connection
        setImmediate(function removeClose() {
            connection.close();
        });
        this.emit("remove");
    }

    /**
     * @param {Number} delay
     */
    scheduleNewConnectionAttempt(delay) {
        if (this.isClosing()) {
            return;
        }

        const self = this;

        this._newConnectionTimeout = setTimeout(
            function newConnectionTimeoutExpired() {
                self._newConnectionTimeout = null;
                if (self.connections.length >= self.coreConnectionsLength) {
                    // new connection can be scheduled while a new connection is being opened
                    // the pool has the appropriate size
                    return;
                }

                if (delay > 0 &amp;&amp; self.options.sni) {
                    // We use delay > 0 as an indication that it's a reconnection.
                    // A reconnection schedule can use delay = 0 as well, but it's a good enough signal.
                    promiseUtils.toBackground(
                        self.options.sni.addressResolver
                            .refresh()
                            .then(() => self._attemptNewConnection()),
                    );
                    return;
                }

                promiseUtils.toBackground(self._attemptNewConnection());
            },
            delay,
        );
    }

    hasScheduledNewConnection() {
        return !!this._newConnectionTimeout || this._opening;
    }

    /**
     * Increases the size of the connection pool in the background, if needed.
     */
    increaseSize() {
        if (
            this.connections.length &lt; this.coreConnectionsLength &amp;&amp;
            !this.hasScheduledNewConnection()
        ) {
            // schedule the next connection in the background
            this.scheduleNewConnectionAttempt(0);
        }
    }

    /**
     * Gets the amount of responses and resets the internal counter.
     * @returns {number}
     */
    getAndResetResponseCounter() {
        const temp = this.responseCounter;
        this.responseCounter = 0;
        return temp;
    }

    /**
     * Gets a boolean indicating if the pool is being closed / shutting down or has been shutdown.
     */
    isClosing() {
        return this._state !== state.initial;
    }

    /**
     * Gracefully waits for all in-flight requests to finish and closes the pool.
     */
    drainAndShutdown() {
        if (this.isClosing()) {
            // Its already closing / shutting down
            return;
        }

        this._state = state.closing;
        this.clearNewConnectionAttempt();

        if (this.connections.length === 0) {
            return this._afterClosing();
        }

        const self = this;
        const connections = this.connections;
        this.connections = utils.emptyArray;
        let closedConnections = 0;
        this.log(
            "info",
            util.format(
                "Draining and closing %d connections to %s",
                connections.length,
                this._address,
            ),
        );
        let wasClosed = false;

        let checkShutdownTimeout;

        for (let i = 0; i &lt; connections.length; i++) {
            const c = connections[i];
            if (c.getInFlight() === 0) {
                getDelayedClose(c)();
                continue;
            }
            c.emitDrain = true;
            c.once("drain", getDelayedClose(c));
        }

        function getDelayedClose(connection) {
            return function delayedClose() {
                connection.close();
                if (++closedConnections &lt; connections.length) {
                    return;
                }
                if (wasClosed) {
                    return;
                }
                wasClosed = true;
                if (checkShutdownTimeout) {
                    clearTimeout(checkShutdownTimeout);
                }
                self._afterClosing();
            };
        }

        // Check that after sometime (readTimeout + 100ms) the connections have been drained
        const delay =
            (this.options.socketOptions.readTimeout ||
                getDefaultOptions().socketOptions.readTimeout) + 100;
        checkShutdownTimeout = setTimeout(function checkShutdown() {
            wasClosed = true;
            connections.forEach(function connectionEach(c) {
                c.close();
            });
            self._afterClosing();
        }, delay);
    }

    _afterClosing() {
        const self = this;

        function resetState() {
            if (self._state === state.shuttingDown) {
                self._state = state.shutDown;
            } else {
                self._state = state.initial;
            }

            self.emit("close");

            if (self._state === state.shutDown) {
                self.emit("shutdown");
            }
        }

        if (this._opening) {
            // The pool is growing, reset the state back to init once the open finished (without any new connection)
            return this.once("open", resetState);
        }

        resetState();
    }

    /**
     * @returns {Promise&lt;void>}
     */
    async shutdown() {
        this.clearNewConnectionAttempt();

        if (!this.connections.length) {
            this._state = state.shutDown;
            return;
        }

        const previousState = this._state;
        this._state = state.shuttingDown;

        if (
            previousState === state.closing ||
            previousState === state.shuttingDown
        ) {
            // When previous state was closing, it will drain all connections and close them
            // When previous state was "shuttingDown", it will close all the connections
            // Once it's completed, shutdown event will be emitted
            return promiseUtils.fromEvent(this, "shutdown");
        }

        await this._closeAllConnections();

        this._state = state.shutDown;
        this.emit("shutdown");
    }

    async _closeAllConnections() {
        const connections = this.connections;
        // point to an empty array
        this.connections = utils.emptyArray;
        if (connections.length === 0) {
            return;
        }

        this.log(
            "info",
            util.format(
                "Closing %d connections to %s",
                connections.length,
                this._address,
            ),
        );

        await Promise.all(connections.map((c) => c.closeAsync()));
    }
}

/** Lazily loads the default options */
function getDefaultOptions() {
    if (defaultOptions === undefined) {
        defaultOptions = clientOptions.defaultOptions();
    }
    return defaultOptions;
}

module.exports = HostConnectionPool;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-auth.html">auth</a></li><li><a href="module-concurrent.html">concurrent</a></li><li><a href="module-datastax.html">datastax</a></li><li><a href="module-errors.html">errors</a></li><li><a href="module-geometry.html">geometry</a></li><li><a href="module-mapping.html">mapping</a></li><li><a href="module-metadata.html">metadata</a></li><li><a href="module-metrics.html">metrics</a></li><li><a href="module-policies.html">policies</a></li><li><a href="module-policies_addressResolution.html">policies/addressResolution</a></li><li><a href="module-policies_loadBalancing.html">policies/loadBalancing</a></li><li><a href="module-policies_reconnection.html">policies/reconnection</a></li><li><a href="module-policies_retry.html">policies/retry</a></li><li><a href="module-policies_speculativeExecution.html">policies/speculativeExecution</a></li><li><a href="module-policies_timestampGeneration.html">policies/timestampGeneration</a></li><li><a href="module-tracker.html">tracker</a></li><li><a href="module-types.html">types</a></li></ul><h3>Classes</h3><ul><li><a href="AddressResolver.html">AddressResolver</a></li><li><a href="AuthResponseRequest.html">AuthResponseRequest</a></li><li><a href="BatchRequest.html">BatchRequest</a></li><li><a href="ByteOrderedToken.html">ByteOrderedToken</a></li><li><a href="Client.html">Client</a></li><li><a href="Connection.html">Connection</a></li><li><a href="ControlConnection.html">ControlConnection</a></li><li><a href="CredentialsRequest.html">CredentialsRequest</a></li><li><a href="Encoder.html">Encoder</a></li><li><a href="ExecuteRequest.html">ExecuteRequest</a></li><li><a href="ExecutionOptions.html">ExecutionOptions</a></li><li><a href="ExecutionProfile.html">ExecutionProfile</a></li><li><a href="FrameReader.html">FrameReader</a></li><li><a href="FrameWriter.html">FrameWriter</a></li><li><a href="HashSet.html">HashSet</a></li><li><a href="Host.html">Host</a></li><li><a href="HostConnectionPool.html">HostConnectionPool</a></li><li><a href="HostMap.html">HostMap</a></li><li><a href="InsightsClient.html">InsightsClient</a></li><li><a href="LineString.html">LineString</a></li><li><a href="Murmur3Token.html">Murmur3Token</a></li><li><a href="Murmur3Tokenizer.html">Murmur3Tokenizer</a></li><li><a href="OperationState.html">OperationState</a></li><li><a href="Point.html">Point</a></li><li><a href="Polygon.html">Polygon</a></li><li><a href="PrepareHandler.html">PrepareHandler</a></li><li><a href="QueryRequest.html">QueryRequest</a></li><li><a href="RandomToken.html">RandomToken</a></li><li><a href="RandomTokenizer.html">RandomTokenizer</a></li><li><a href="Request.html">Request</a></li><li><a href="RequestExecution.html">RequestExecution</a></li><li><a href="RequestHandler.html">RequestHandler</a></li><li><a href="StartupRequest.html">StartupRequest</a></li><li><a href="StreamIdStack.html">StreamIdStack</a></li><li><a href="Token.html">Token</a></li><li><a href="TokenRange.html">TokenRange</a></li><li><a href="Tokenizer.html">Tokenizer</a></li><li><a href="TransitionalModePlainTextAuthenticator.html">TransitionalModePlainTextAuthenticator</a></li><li><a href="WriteQueue.html">WriteQueue</a></li><li><a href="module-auth-AuthProvider.html">AuthProvider</a></li><li><a href="module-auth-Authenticator.html">Authenticator</a></li><li><a href="module-auth-DseGssapiAuthProvider.html">DseGssapiAuthProvider</a></li><li><a href="module-auth-DsePlainTextAuthProvider.html">DsePlainTextAuthProvider</a></li><li><a href="module-auth-PlainTextAuthProvider.html">PlainTextAuthProvider</a></li><li><a href="module-errors-ArgumentError.html">ArgumentError</a></li><li><a href="module-errors-AuthenticationError.html">AuthenticationError</a></li><li><a href="module-errors-BusyConnectionError.html">BusyConnectionError</a></li><li><a href="module-errors-DriverInternalError.html">DriverInternalError</a></li><li><a href="module-errors-NoHostAvailableError.html">NoHostAvailableError</a></li><li><a href="module-errors-NotSupportedError.html">NotSupportedError</a></li><li><a href="module-errors-OperationTimedOutError.html">OperationTimedOutError</a></li><li><a href="module-errors-ResponseError.html">ResponseError</a></li><li><a href="module-mapping-DefaultTableMappings.html">DefaultTableMappings</a></li><li><a href="module-mapping-Mapper.html">Mapper</a></li><li><a href="module-mapping-ModelBatchItem.html">ModelBatchItem</a></li><li><a href="module-mapping-ModelMapper.html">ModelMapper</a></li><li><a href="module-mapping-Result.html">Result</a></li><li><a href="module-mapping-UnderscoreCqlToCamelCaseMappings.html">UnderscoreCqlToCamelCaseMappings</a></li><li><a href="module-metadata-Aggregate.html">Aggregate</a></li><li><a href="module-metadata-ClientState.html">ClientState</a></li><li><a href="module-metadata-DataCollection.html">DataCollection</a></li><li><a href="module-metadata-Index.html">Index</a></li><li><a href="module-metadata-MaterializedView.html">MaterializedView</a></li><li><a href="module-metadata-Metadata.html">Metadata</a></li><li><a href="module-metadata-SchemaFunction.html">SchemaFunction</a></li><li><a href="module-metadata-TableMetadata.html">TableMetadata</a></li><li><a href="module-metrics-DefaultMetrics.html">DefaultMetrics</a></li><li><a href="module-policies_addressResolution-AddressTranslator.html">AddressTranslator</a></li><li><a href="module-policies_addressResolution-EC2MultiRegionTranslator.html">EC2MultiRegionTranslator</a></li><li><a href="module-policies_loadBalancing-AllowListPolicy.html">AllowListPolicy</a></li><li><a href="module-policies_loadBalancing-DCAwareRoundRobinPolicy.html">DCAwareRoundRobinPolicy</a></li><li><a href="module-policies_loadBalancing-DefaultLoadBalancingPolicy.html">DefaultLoadBalancingPolicy</a></li><li><a href="module-policies_loadBalancing-LoadBalancingPolicy.html">LoadBalancingPolicy</a></li><li><a href="module-policies_loadBalancing-RoundRobinPolicy.html">RoundRobinPolicy</a></li><li><a href="module-policies_loadBalancing-TokenAwarePolicy.html">TokenAwarePolicy</a></li><li><a href="module-policies_loadBalancing-WhiteListPolicy.html">WhiteListPolicy</a></li><li><a href="module-policies_reconnection-ConstantReconnectionPolicy.html">ConstantReconnectionPolicy</a></li><li><a href="module-policies_reconnection-ExponentialReconnectionPolicy.html">ExponentialReconnectionPolicy</a></li><li><a href="module-policies_reconnection-ReconnectionPolicy.html">ReconnectionPolicy</a></li><li><a href="module-policies_retry-FallthroughRetryPolicy.html">FallthroughRetryPolicy</a></li><li><a href="module-policies_retry-IdempotenceAwareRetryPolicy.html">IdempotenceAwareRetryPolicy</a></li><li><a href="module-policies_retry-RetryPolicy.html">RetryPolicy</a></li><li><a href="module-policies_speculativeExecution-ConstantSpeculativeExecutionPolicy.html">ConstantSpeculativeExecutionPolicy</a></li><li><a href="module-policies_speculativeExecution-NoSpeculativeExecutionPolicy.html">NoSpeculativeExecutionPolicy</a></li><li><a href="module-policies_speculativeExecution-SpeculativeExecutionPolicy.html">SpeculativeExecutionPolicy</a></li><li><a href="module-policies_timestampGeneration-MonotonicTimestampGenerator.html">MonotonicTimestampGenerator</a></li><li><a href="module-policies_timestampGeneration-TimestampGenerator.html">TimestampGenerator</a></li><li><a href="module-tracker-RequestLogger.html">RequestLogger</a></li><li><a href="module-types-BigDecimal.html">BigDecimal</a></li><li><a href="module-types-Duration.html">Duration</a></li><li><a href="module-types-InetAddress.html">InetAddress</a></li><li><a href="module-types-Integer.html">Integer</a></li><li><a href="module-types-LocalDate.html">LocalDate</a></li><li><a href="module-types-LocalTime.html">LocalTime</a></li><li><a href="module-types-Long.html">Long</a></li><li><a href="module-types-ResultSet.html">ResultSet</a></li><li><a href="module-types-ResultStream.html">ResultStream</a></li><li><a href="module-types-Row.html">Row</a></li><li><a href="module-types-TimeUuid.html">TimeUuid</a></li><li><a href="module-types-Tuple.html">Tuple</a></li><li><a href="module-types-Uuid.html">Uuid</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-mapping-TableMappings.html">TableMappings</a></li><li><a href="module-metrics-ClientMetrics.html">ClientMetrics</a></li><li><a href="module-tracker-RequestTracker.html">RequestTracker</a></li></ul><h3>Events</h3><ul><li><a href="Client.html#event:hostAdd">hostAdd</a></li><li><a href="Client.html#event:hostDown">hostDown</a></li><li><a href="Client.html#event:hostRemove">hostRemove</a></li><li><a href="Client.html#event:hostUp">hostUp</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Parser">Parser</a></li><li><a href="global.html#Protocol">Protocol</a></li><li><a href="global.html#ResultEmitter">ResultEmitter</a></li><li><a href="global.html#adaptNamedParamsPrepared">adaptNamedParamsPrepared</a></li><li><a href="global.html#adaptNamedParamsWithHints">adaptNamedParamsWithHints</a></li><li><a href="global.html#allocBuffer">allocBuffer</a></li><li><a href="global.html#allocBufferFromArray">allocBufferFromArray</a></li><li><a href="global.html#allocBufferFromString">allocBufferFromString</a></li><li><a href="global.html#allocBufferUnsafe">allocBufferUnsafe</a></li><li><a href="global.html#arrayIterator">arrayIterator</a></li><li><a href="global.html#binarySearch">binarySearch</a></li><li><a href="global.html#callbackOnce">callbackOnce</a></li><li><a href="global.html#copyBuffer">copyBuffer</a></li><li><a href="global.html#coreConnectionsPerHostV2">coreConnectionsPerHostV2</a></li><li><a href="global.html#coreConnectionsPerHostV3">coreConnectionsPerHostV3</a></li><li><a href="global.html#deepExtend">deepExtend</a></li><li><a href="global.html#defaultOptions">defaultOptions</a></li><li><a href="global.html#defaultPromiseFactory">defaultPromiseFactory</a></li><li><a href="global.html#defaultReleaseDelay">defaultReleaseDelay</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#each">each</a></li><li><a href="global.html#eachSeries">eachSeries</a></li><li><a href="global.html#emptyArray">emptyArray</a></li><li><a href="global.html#emptyObject">emptyObject</a></li><li><a href="global.html#encodeVector">encodeVector</a></li><li><a href="global.html#errorCodes">errorCodes</a></li><li><a href="global.html#extend">extend</a></li><li><a href="global.html#fixStack">fixStack</a></li><li><a href="global.html#forEachOf">forEachOf</a></li><li><a href="global.html#fromCallback">fromCallback</a></li><li><a href="global.html#fromEvent">fromEvent</a></li><li><a href="global.html#fromSignedByte">fromSignedByte</a></li><li><a href="global.html#getCallback">getCallback</a></li><li><a href="global.html#getDefaultOptions">getDefaultOptions</a></li><li><a href="global.html#groupSize">groupSize</a></li><li><a href="global.html#ifUndefined">ifUndefined</a></li><li><a href="global.html#ifUndefined3">ifUndefined3</a></li><li><a href="global.html#insertSorted">insertSorted</a></li><li><a href="global.html#iteratorToArray">iteratorToArray</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#mapSeries">mapSeries</a></li><li><a href="global.html#maxGroupsFor2Bytes">maxGroupsFor2Bytes</a></li><li><a href="global.html#maxInt">maxInt</a></li><li><a href="global.html#maxRequestsPerConnectionV2">maxRequestsPerConnectionV2</a></li><li><a href="global.html#maxRequestsPerConnectionV3">maxRequestsPerConnectionV3</a></li><li><a href="global.html#newQueryPlan">newQueryPlan</a></li><li><a href="global.html#objectValues">objectValues</a></li><li><a href="global.html#optionalCallback">optionalCallback</a></li><li><a href="global.html#parallel">parallel</a></li><li><a href="global.html#parseVectorTypeArgs">parseVectorTypeArgs</a></li><li><a href="global.html#promiseWrapper">promiseWrapper</a></li><li><a href="global.html#releasableSize">releasableSize</a></li><li><a href="global.html#resultFlag">resultFlag</a></li><li><a href="global.html#rowBuffer">rowBuffer</a></li><li><a href="global.html#series">series</a></li><li><a href="global.html#setMetadataDependent">setMetadataDependent</a></li><li><a href="global.html#shiftToGroup">shiftToGroup</a></li><li><a href="global.html#stringRepeat">stringRepeat</a></li><li><a href="global.html#throwNotSupported">throwNotSupported</a></li><li><a href="global.html#times">times</a></li><li><a href="global.html#timesLimit">timesLimit</a></li><li><a href="global.html#timesSeries">timesSeries</a></li><li><a href="global.html#toBackground">toBackground</a></li><li><a href="global.html#toCallback">toCallback</a></li><li><a href="global.html#toLowerCaseProperties">toLowerCaseProperties</a></li><li><a href="global.html#totalLength">totalLength</a></li><li><a href="global.html#validateFn">validateFn</a></li><li><a href="global.html#whilst">whilst</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun Nov 24 2024 15:06:54 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
