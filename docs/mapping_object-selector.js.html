<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: mapping/object-selector.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: mapping/object-selector.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

const keyMatches = {
    all: 1,
    none: 0,
    some: -1,
};

/**
 * Provides utility methods to choose the correct tables and views that should be included in a statement.
 * @ignore
 */
class ObjectSelector {
    /**
     * Gets the table/view that should be used to execute the SELECT query.
     * @param {Client} client
     * @param {ModelMappingInfo} info
     * @param {Boolean} allPKsDefined
     * @param {Array} propertiesInfo
     * @param {Array} fieldsInfo
     * @param {Array&lt;Array&lt;String>>} orderByColumns
     * @return {Promise&lt;String>} A promise that resolves to a table names.
     */
    static getForSelect(
        client,
        info,
        allPKsDefined,
        propertiesInfo,
        fieldsInfo,
        orderByColumns,
    ) {
        return Promise.all(
            info.tables.map((t) => {
                if (t.isView) {
                    return client.metadata.getMaterializedView(
                        info.keyspace,
                        t.name,
                    );
                }
                return client.metadata.getTable(info.keyspace, t.name);
            }),
        ).then((tables) => {
            for (let i = 0; i &lt; tables.length; i++) {
                const table = tables[i];
                if (table === null) {
                    throw new Error(
                        `Table "${info.tables[i].name}" could not be retrieved`,
                    );
                }

                if (
                    keysAreIncluded(table.partitionKeys, propertiesInfo) !==
                    keyMatches.all
                ) {
                    // Not all the partition keys are covered
                    continue;
                }

                if (allPKsDefined) {
                    if (
                        keysAreIncluded(
                            table.clusteringKeys,
                            propertiesInfo,
                        ) !== keyMatches.all
                    ) {
                        // All clustering keys should be included as allPKsDefined flag is set
                        continue;
                    }
                }

                if (propertiesInfo.length > table.partitionKeys.length) {
                    // Check that the Where clause is composed by partition and clustering keys
                    const allPropertiesArePrimaryKeys = propertiesInfo.reduce(
                        (acc, p) =>
                            acc &amp;&amp;
                            (contains(
                                table.partitionKeys,
                                (c) => c.name === p.columnName,
                            ) ||
                                contains(
                                    table.clusteringKeys,
                                    (c) => c.name === p.columnName,
                                )),
                        true,
                    );

                    if (!allPropertiesArePrimaryKeys) {
                        continue;
                    }
                }

                // All fields must be contained
                const containsAllFields = fieldsInfo.reduce(
                    (acc, p) =>
                        acc &amp;&amp; table.columnsByName[p.columnName] !== undefined,
                    true,
                );

                if (!containsAllFields) {
                    continue;
                }

                // CQL:
                // - "ORDER BY" is currently only supported on the clustered columns of the PRIMARY KEY
                // - "ORDER BY" currently only support the ordering of columns following their declared order in
                //   the PRIMARY KEY
                //
                // In the mapper, we validate that the ORDER BY columns appear in the same order as in the clustering keys
                const containsAllOrderByColumns = orderByColumns.reduce(
                    (acc, order, index) => {
                        if (!acc) {
                            return false;
                        }

                        const ck = table.clusteringKeys[index];

                        return ck &amp;&amp; ck.name === order[0];
                    },
                    true,
                );

                if (!containsAllOrderByColumns) {
                    continue;
                }

                return table.name;
            }

            let message = `No table matches the filter (${allPKsDefined ? "all PKs have to be specified" : "PKs"}): [${propertiesInfo.map(
                (p) => p.columnName,
            )}]`;

            if (fieldsInfo.length > 0) {
                message += `; fields: [${fieldsInfo.map((p) => p.columnName)}]`;
            }
            if (orderByColumns.length > 0) {
                message += `; orderBy: [${orderByColumns.map((item) => item[0])}]`;
            }

            throw new Error(message);
        });
    }

    /** Returns the name of the first table */
    static getForSelectAll(info) {
        return info.tables[0].name;
    }

    /**
     * Gets the tables that should be used to execute the INSERT query.
     * @param {Client} client
     * @param {ModelMappingInfo} info
     * @param {Array} propertiesInfo
     * @return {Promise&lt;Array&lt;TableMetadata>>} A promise that resolves to an Array of tables.
     */
    static getForInsert(client, info, propertiesInfo) {
        return Promise.all(
            info.tables
                .filter((t) => !t.isView)
                .map((t) => client.metadata.getTable(info.keyspace, t.name)),
        ).then((tables) => {
            const filteredTables = tables.filter((table, i) => {
                if (table === null) {
                    throw new Error(
                        `Table "${info.tables[i].name}" could not be retrieved`,
                    );
                }

                if (
                    keysAreIncluded(table.partitionKeys, propertiesInfo) !==
                    keyMatches.all
                ) {
                    // Not all the partition keys are covered
                    return false;
                }

                const clusteringKeyMatches = keysAreIncluded(
                    table.clusteringKeys,
                    propertiesInfo,
                );

                // All clustering keys should be included or it can be inserting a static column value
                if (clusteringKeyMatches === keyMatches.all) {
                    return true;
                }

                if (clusteringKeyMatches === keyMatches.some) {
                    return false;
                }

                const staticColumns = staticColumnCount(table);
                return (
                    propertiesInfo.length ===
                        table.partitionKeys.length + staticColumns &amp;&amp;
                    staticColumns > 0
                );
            });

            if (filteredTables.length === 0) {
                throw new Error(
                    `No table matches (all PKs have to be specified) fields: [${propertiesInfo.map(
                        (p) => p.columnName,
                    )}]`,
                );
            }

            return filteredTables;
        });
    }

    /**
     * Gets the tables that should be used to execute the UPDATE query.
     * @param {Client} client
     * @param {ModelMappingInfo} info
     * @param {Array} propertiesInfo
     * @param {Array} when
     * @return {Promise&lt;Array&lt;TableMetadata>>} A promise that resolves to an Array of tables.
     */
    static getForUpdate(client, info, propertiesInfo, when) {
        return Promise.all(
            info.tables
                .filter((t) => !t.isView)
                .map((t) => client.metadata.getTable(info.keyspace, t.name)),
        ).then((tables) => {
            const filteredTables = tables.filter((table, i) => {
                if (table === null) {
                    throw new Error(
                        `Table "${info.tables[i].name}" could not be retrieved`,
                    );
                }

                if (
                    keysAreIncluded(table.partitionKeys, propertiesInfo) !==
                    keyMatches.all
                ) {
                    // Not all the partition keys are covered
                    return false;
                }

                const clusteringKeyMatches = keysAreIncluded(
                    table.clusteringKeys,
                    propertiesInfo,
                );

                // All clustering keys should be included or it can be updating a static column value
                if (clusteringKeyMatches === keyMatches.some) {
                    return false;
                }

                if (
                    clusteringKeyMatches === keyMatches.none &amp;&amp;
                    !hasStaticColumn(table)
                ) {
                    return false;
                }

                const applicableColumns = propertiesInfo.reduce(
                    (acc, p) =>
                        acc +
                        (table.columnsByName[p.columnName] !== undefined
                            ? 1
                            : 0),
                    0,
                );

                if (
                    applicableColumns &lt;=
                    table.partitionKeys.length + table.clusteringKeys.length
                ) {
                    if (
                        !hasStaticColumn(table) ||
                        applicableColumns &lt;= table.partitionKeys.length
                    ) {
                        // UPDATE statement does not contain columns to SET
                        return false;
                    }
                }

                // "when" conditions should be contained in the table
                return when.reduce(
                    (acc, p) =>
                        acc &amp;&amp; table.columnsByName[p.columnName] !== undefined,
                    true,
                );
            });

            if (filteredTables.length === 0) {
                let message = `No table matches (all PKs and columns to set have to be specified) fields: [${propertiesInfo.map(
                    (p) => p.columnName,
                )}]`;

                if (when.length > 0) {
                    message += `; condition: [${when.map((p) => p.columnName)}]`;
                }

                throw new Error(message);
            }

            return filteredTables;
        });
    }

    /**
     * Gets the tables that should be used to execute the DELETE query.
     * @param {Client} client
     * @param {ModelMappingInfo} info
     * @param {Array} propertiesInfo
     * @param {Array} when
     * @return {Promise&lt;Array&lt;TableMetadata>>} A promise that resolves to an Array of tables.
     */
    static getForDelete(client, info, propertiesInfo, when) {
        return Promise.all(
            info.tables
                .filter((t) => !t.isView)
                .map((t) => client.metadata.getTable(info.keyspace, t.name)),
        ).then((tables) => {
            const filteredTables = tables.filter((table, i) => {
                if (table === null) {
                    throw new Error(
                        `Table "${info.tables[i].name}" could not be retrieved`,
                    );
                }

                // All partition and clustering keys from the table should be included in the document
                const keyNames = table.partitionKeys
                    .concat(table.clusteringKeys)
                    .map((k) => k.name);
                const columns = propertiesInfo.map((p) => p.columnName);

                for (let i = 0; i &lt; keyNames.length; i++) {
                    if (columns.indexOf(keyNames[i]) === -1) {
                        return false;
                    }
                }

                // "when" conditions should be contained in the table
                return when.reduce(
                    (acc, p) =>
                        acc &amp;&amp; table.columnsByName[p.columnName] !== undefined,
                    true,
                );
            });

            if (filteredTables.length === 0) {
                let message = `No table matches (all PKs have to be specified) fields: [${propertiesInfo.map(
                    (p) => p.columnName,
                )}]`;

                if (when.length > 0) {
                    message += `; condition: [${when.map((p) => p.columnName)}]`;
                }

                throw new Error(message);
            }

            return filteredTables;
        });
    }
}

function contains(arr, fn) {
    return arr.filter(fn).length > 0;
}

/**
 * Returns the amount of matches for a given key
 * @private
 * @param {Array} keys
 * @param {Array} propertiesInfo
 */
function keysAreIncluded(keys, propertiesInfo) {
    if (keys.length === 0) {
        return keyMatches.all;
    }

    // Filtering by name might look slow / ineffective to using hash maps
    // but we expect `keys` and `propertiesInfo` to contain only few items
    const matches = propertiesInfo.reduce(
        (acc, p) =>
            acc + (contains(keys, (k) => p.columnName === k.name) ? 1 : 0),
        0,
    );
    if (matches === 0) {
        return keyMatches.none;
    }

    return matches === keys.length ? keyMatches.all : keyMatches.some;
}

function hasStaticColumn(table) {
    return staticColumnCount(table) > 0;
}

function staticColumnCount(table) {
    return table.columns.reduce(
        (acc, column) => acc + (column.isStatic ? 1 : 0),
        0,
    );
}

module.exports = ObjectSelector;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-auth.html">auth</a></li><li><a href="module-concurrent.html">concurrent</a></li><li><a href="module-datastax.html">datastax</a></li><li><a href="module-errors.html">errors</a></li><li><a href="module-geometry.html">geometry</a></li><li><a href="module-mapping.html">mapping</a></li><li><a href="module-metadata.html">metadata</a></li><li><a href="module-metrics.html">metrics</a></li><li><a href="module-policies.html">policies</a></li><li><a href="module-policies_addressResolution.html">policies/addressResolution</a></li><li><a href="module-policies_loadBalancing.html">policies/loadBalancing</a></li><li><a href="module-policies_reconnection.html">policies/reconnection</a></li><li><a href="module-policies_retry.html">policies/retry</a></li><li><a href="module-policies_speculativeExecution.html">policies/speculativeExecution</a></li><li><a href="module-policies_timestampGeneration.html">policies/timestampGeneration</a></li><li><a href="module-tracker.html">tracker</a></li><li><a href="module-types.html">types</a></li></ul><h3>Classes</h3><ul><li><a href="AddressResolver.html">AddressResolver</a></li><li><a href="ByteOrderedToken.html">ByteOrderedToken</a></li><li><a href="Client.html">Client</a></li><li><a href="Encoder.html">Encoder</a></li><li><a href="ExecutionOptions.html">ExecutionOptions</a></li><li><a href="ExecutionProfile.html">ExecutionProfile</a></li><li><a href="HashSet.html">HashSet</a></li><li><a href="Host.html">Host</a></li><li><a href="HostMap.html">HostMap</a></li><li><a href="LineString.html">LineString</a></li><li><a href="Murmur3Token.html">Murmur3Token</a></li><li><a href="Point.html">Point</a></li><li><a href="Polygon.html">Polygon</a></li><li><a href="RandomToken.html">RandomToken</a></li><li><a href="Token.html">Token</a></li><li><a href="TokenRange.html">TokenRange</a></li><li><a href="TransitionalModePlainTextAuthenticator.html">TransitionalModePlainTextAuthenticator</a></li><li><a href="module-auth-AuthProvider.html">AuthProvider</a></li><li><a href="module-auth-Authenticator.html">Authenticator</a></li><li><a href="module-auth-PlainTextAuthProvider.html">PlainTextAuthProvider</a></li><li><a href="module-errors-ArgumentError.html">ArgumentError</a></li><li><a href="module-errors-AuthenticationError.html">AuthenticationError</a></li><li><a href="module-errors-BusyConnectionError.html">BusyConnectionError</a></li><li><a href="module-errors-DriverInternalError.html">DriverInternalError</a></li><li><a href="module-errors-NoHostAvailableError.html">NoHostAvailableError</a></li><li><a href="module-errors-NotSupportedError.html">NotSupportedError</a></li><li><a href="module-errors-OperationTimedOutError.html">OperationTimedOutError</a></li><li><a href="module-errors-ResponseError.html">ResponseError</a></li><li><a href="module-mapping-DefaultTableMappings.html">DefaultTableMappings</a></li><li><a href="module-mapping-Mapper.html">Mapper</a></li><li><a href="module-mapping-ModelBatchItem.html">ModelBatchItem</a></li><li><a href="module-mapping-ModelMapper.html">ModelMapper</a></li><li><a href="module-mapping-Result.html">Result</a></li><li><a href="module-mapping-UnderscoreCqlToCamelCaseMappings.html">UnderscoreCqlToCamelCaseMappings</a></li><li><a href="module-metadata-Aggregate.html">Aggregate</a></li><li><a href="module-metadata-ClientState.html">ClientState</a></li><li><a href="module-metadata-DataCollection.html">DataCollection</a></li><li><a href="module-metadata-Index.html">Index</a></li><li><a href="module-metadata-MaterializedView.html">MaterializedView</a></li><li><a href="module-metadata-Metadata.html">Metadata</a></li><li><a href="module-metadata-SchemaFunction.html">SchemaFunction</a></li><li><a href="module-metadata-TableMetadata.html">TableMetadata</a></li><li><a href="module-metrics-DefaultMetrics.html">DefaultMetrics</a></li><li><a href="module-policies_addressResolution-AddressTranslator.html">AddressTranslator</a></li><li><a href="module-policies_addressResolution-EC2MultiRegionTranslator.html">EC2MultiRegionTranslator</a></li><li><a href="module-policies_loadBalancing-AllowListPolicy.html">AllowListPolicy</a></li><li><a href="module-policies_loadBalancing-DCAwareRoundRobinPolicy.html">DCAwareRoundRobinPolicy</a></li><li><a href="module-policies_loadBalancing-DefaultLoadBalancingPolicy.html">DefaultLoadBalancingPolicy</a></li><li><a href="module-policies_loadBalancing-LoadBalancingPolicy.html">LoadBalancingPolicy</a></li><li><a href="module-policies_loadBalancing-RoundRobinPolicy.html">RoundRobinPolicy</a></li><li><a href="module-policies_loadBalancing-TokenAwarePolicy.html">TokenAwarePolicy</a></li><li><a href="module-policies_loadBalancing-WhiteListPolicy.html">WhiteListPolicy</a></li><li><a href="module-policies_reconnection-ConstantReconnectionPolicy.html">ConstantReconnectionPolicy</a></li><li><a href="module-policies_reconnection-ExponentialReconnectionPolicy.html">ExponentialReconnectionPolicy</a></li><li><a href="module-policies_reconnection-ReconnectionPolicy.html">ReconnectionPolicy</a></li><li><a href="module-policies_retry-FallthroughRetryPolicy.html">FallthroughRetryPolicy</a></li><li><a href="module-policies_retry-IdempotenceAwareRetryPolicy.html">IdempotenceAwareRetryPolicy</a></li><li><a href="module-policies_retry-RetryPolicy.html">RetryPolicy</a></li><li><a href="module-policies_speculativeExecution-ConstantSpeculativeExecutionPolicy.html">ConstantSpeculativeExecutionPolicy</a></li><li><a href="module-policies_speculativeExecution-NoSpeculativeExecutionPolicy.html">NoSpeculativeExecutionPolicy</a></li><li><a href="module-policies_speculativeExecution-SpeculativeExecutionPolicy.html">SpeculativeExecutionPolicy</a></li><li><a href="module-policies_timestampGeneration-MonotonicTimestampGenerator.html">MonotonicTimestampGenerator</a></li><li><a href="module-policies_timestampGeneration-TimestampGenerator.html">TimestampGenerator</a></li><li><a href="module-tracker-RequestLogger.html">RequestLogger</a></li><li><a href="module-types-BigDecimal.html">BigDecimal</a></li><li><a href="module-types-Duration.html">Duration</a></li><li><a href="module-types-InetAddress.html">InetAddress</a></li><li><a href="module-types-Integer.html">Integer</a></li><li><a href="module-types-LocalDate.html">LocalDate</a></li><li><a href="module-types-LocalTime.html">LocalTime</a></li><li><a href="module-types-Long.html">Long</a></li><li><a href="module-types-ResultSet.html">ResultSet</a></li><li><a href="module-types-ResultStream.html">ResultStream</a></li><li><a href="module-types-Row.html">Row</a></li><li><a href="module-types-TimeUuid.html">TimeUuid</a></li><li><a href="module-types-Tuple.html">Tuple</a></li><li><a href="module-types-Uuid.html">Uuid</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-mapping-TableMappings.html">TableMappings</a></li><li><a href="module-metrics-ClientMetrics.html">ClientMetrics</a></li><li><a href="module-tracker-RequestTracker.html">RequestTracker</a></li></ul><h3>Events</h3><ul><li><a href="Client.html#event:hostAdd">hostAdd</a></li><li><a href="Client.html#event:hostDown">hostDown</a></li><li><a href="Client.html#event:hostRemove">hostRemove</a></li><li><a href="Client.html#event:hostUp">hostUp</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Integer">Integer</a></li><li><a href="global.html#adaptNamedParamsPrepared">adaptNamedParamsPrepared</a></li><li><a href="global.html#adaptNamedParamsWithHints">adaptNamedParamsWithHints</a></li><li><a href="global.html#allocBuffer">allocBuffer</a></li><li><a href="global.html#allocBufferFromArray">allocBufferFromArray</a></li><li><a href="global.html#allocBufferFromString">allocBufferFromString</a></li><li><a href="global.html#allocBufferUnsafe">allocBufferUnsafe</a></li><li><a href="global.html#arbitraryValueToBigInt">arbitraryValueToBigInt</a></li><li><a href="global.html#arrayIterator">arrayIterator</a></li><li><a href="global.html#bigintToLong">bigintToLong</a></li><li><a href="global.html#binarySearch">binarySearch</a></li><li><a href="global.html#callbackOnce">callbackOnce</a></li><li><a href="global.html#convertHints">convertHints</a></li><li><a href="global.html#copyBuffer">copyBuffer</a></li><li><a href="global.html#coreConnectionsPerHostV2">coreConnectionsPerHostV2</a></li><li><a href="global.html#coreConnectionsPerHostV3">coreConnectionsPerHostV3</a></li><li><a href="global.html#deepExtend">deepExtend</a></li><li><a href="global.html#defaultOptions">defaultOptions</a></li><li><a href="global.html#defaultPromiseFactory">defaultPromiseFactory</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#each">each</a></li><li><a href="global.html#eachSeries">eachSeries</a></li><li><a href="global.html#emptyArray">emptyArray</a></li><li><a href="global.html#emptyObject">emptyObject</a></li><li><a href="global.html#encodeListLike">encodeListLike</a></li><li><a href="global.html#encodeMap">encodeMap</a></li><li><a href="global.html#encodeTuple">encodeTuple</a></li><li><a href="global.html#encodeUdt">encodeUdt</a></li><li><a href="global.html#encodeVector">encodeVector</a></li><li><a href="global.html#ensureNumber">ensureNumber</a></li><li><a href="global.html#ensureValue">ensureValue</a></li><li><a href="global.html#extend">extend</a></li><li><a href="global.html#fixStack">fixStack</a></li><li><a href="global.html#forEachOf">forEachOf</a></li><li><a href="global.html#fromCallback">fromCallback</a></li><li><a href="global.html#fromEvent">fromEvent</a></li><li><a href="global.html#getCallback">getCallback</a></li><li><a href="global.html#getColumnsMetadata">getColumnsMetadata</a></li><li><a href="global.html#getCqlObject">getCqlObject</a></li><li><a href="global.html#getRowsFromResultsWrapper">getRowsFromResultsWrapper</a></li><li><a href="global.html#getWrapped">getWrapped</a></li><li><a href="global.html#guessTypeChecked">guessTypeChecked</a></li><li><a href="global.html#ifUndefined">ifUndefined</a></li><li><a href="global.html#ifUndefined3">ifUndefined3</a></li><li><a href="global.html#insertSorted">insertSorted</a></li><li><a href="global.html#iteratorToArray">iteratorToArray</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#longToBigint">longToBigint</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#mapSeries">mapSeries</a></li><li><a href="global.html#maxInt">maxInt</a></li><li><a href="global.html#maxRequestsPerConnectionV2">maxRequestsPerConnectionV2</a></li><li><a href="global.html#maxRequestsPerConnectionV3">maxRequestsPerConnectionV3</a></li><li><a href="global.html#napiErrorHandler">napiErrorHandler</a></li><li><a href="global.html#newQueryPlan">newQueryPlan</a></li><li><a href="global.html#objectValues">objectValues</a></li><li><a href="global.html#optionalCallback">optionalCallback</a></li><li><a href="global.html#parallel">parallel</a></li><li><a href="global.html#parseParams">parseParams</a></li><li><a href="global.html#parseVectorTypeArgs">parseVectorTypeArgs</a></li><li><a href="global.html#promiseWrapper">promiseWrapper</a></li><li><a href="global.html#queryOptionsIntoWrapper">queryOptionsIntoWrapper</a></li><li><a href="global.html#rustConvertHint">rustConvertHint</a></li><li><a href="global.html#series">series</a></li><li><a href="global.html#setMetadataDependent">setMetadataDependent</a></li><li><a href="global.html#stringRepeat">stringRepeat</a></li><li><a href="global.html#throwNotSupported">throwNotSupported</a></li><li><a href="global.html#times">times</a></li><li><a href="global.html#timesLimit">timesLimit</a></li><li><a href="global.html#timesSeries">timesSeries</a></li><li><a href="global.html#toBackground">toBackground</a></li><li><a href="global.html#toCallback">toCallback</a></li><li><a href="global.html#toLowerCaseProperties">toLowerCaseProperties</a></li><li><a href="global.html#totalLength">totalLength</a></li><li><a href="global.html#validateFn">validateFn</a></li><li><a href="global.html#whilst">whilst</a></li><li><a href="global.html#wrapValueBasedOnType">wrapValueBasedOnType</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Oct 22 2025 11:03:50 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
