<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: types/cql-utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: types/cql-utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

const util = require("util");
const types = require("./index");
const rust = require("../../index");
const { ResponseError } = require("../errors");
const TimeUuid = require("./time-uuid");
const Uuid = require("./uuid");
const Duration = require("./duration");
const LocalDate = require("./local-date");
const LocalTime = require("./local-time");
const InetAddress = require("./inet-address");
const { guessType } = require("./type-guessing");
const { arbitraryValueToBigInt } = require("../new-utils");

/**
 * Ensures the value isn't one of many ways to express null value
 * @param {string} message Error message if value is "null"
 * @throws {TypeError} Throws an error if the value is "null"
 */
function ensureValue(val, message) {
    if (val === null || typeof val === "undefined" || val === types.unset)
        throw new TypeError(message);
}

/**
 * Guess the type, and if the type cannot be guessed, throw an error.
 * @param {any} value
 * @returns {rust.ComplexType} type guess, converted to ``ComplexType`` object
 */
function guessTypeChecked(value) {
    let type = rustConvertHint(guessType(value));
    if (!type) {
        throw new TypeError(
            "Target data type could not be guessed, you should use prepared statements for accurate type mapping. Value: " +
                util.inspect(value),
        );
    }
    return type;
}

/**
 * Wraps each of the elements into given subtype
 * @param {Array} values
 * @param {rust.ComplexType} subtype
 * @returns {Array&lt;rust.QueryParameterWrapper>}
 */
function encodeListLike(values, subtype) {
    if (!Array.isArray(values))
        throw new TypeError(
            `Not a valid list value, expected Array obtained ${util.inspect(values)}`,
        );

    if (!subtype) subtype = guessTypeChecked(values[0]);

    let res = [];
    for (let i = 0; i &lt; values.length; i++) {
        // This requirement is based on the datastax code
        ensureValue(
            values[i],
            "A collection can't contain null or unset values",
        );
        res.push(wrapValueBasedOnType(subtype, values[i]));
    }
    return res;
}

/**
 * @param {*} value
 * @param {rust.ComplexType} parentType
 * @returns {Array&lt;Array&lt;rust.QueryParameterWrapper>>}
 */
function encodeMap(value, parentType) {
    const keySubtype = parentType.getFirstSupportType();
    const valueSubtype = parentType.getSecondSupportType();

    let res = [];

    for (const key in value) {
        if (!value.hasOwnProperty(key)) {
            continue;
        }
        const val = value[key];
        ensureValue(val, "A collection can't contain null or unset values");
        ensureValue(key, "A collection can't contain null or unset values");
        res.push([
            wrapValueBasedOnType(keySubtype || guessTypeChecked(key), key),
            wrapValueBasedOnType(valueSubtype || guessTypeChecked(val), val),
        ]);
    }
    return res;
}

/**
 * Ensures the provided value is non NaN. If it is, throws an error
 * @param {any} value
 */
function ensureNumber(value) {
    if (Number.isNaN(value)) {
        throw new TypeError("Expected Number, obtained " + util.inspect(value));
    }
}

/**
 * Wrap value into MaybeUnsetQueryParameterWrapper based on the type
 * @param {rust.ComplexType} type
 * @param {*} value
 * @returns {rust.MaybeUnsetQueryParameterWrapper?}
 */
function getWrapped(type, value) {
    // Unsets were introduced in CQLv3, and the backend of the driver - Rust driver -
    // works only with version >= 4 of CQL, so unset will always be supported.
    if (value === null) {
        return null;
    } else if (value === types.unset) {
        return rust.MaybeUnsetQueryParameterWrapper.unset();
    }
    return rust.MaybeUnsetQueryParameterWrapper.fromNonNullNonUnsetValue(
        wrapValueBasedOnType(type, value),
    );
}

/**
 * Wrap value, which is not Unset, into QueryParameterWrapper based on the type
 * @param {rust.ComplexType} type
 * @param {*} value
 * @returns {rust.QueryParameterWrapper}
 */
function wrapValueBasedOnType(type, value) {
    let encodedElement;
    let tmpElement;
    // To increase clarity of the error messages, in case value is of different type then expected,
    // when we call some methods on value variable, type is checked explicitly.
    // In other cases default Error will be thrown, which has message meaningful for the user.
    switch (type.baseType) {
        case rust.CqlType.Ascii:
            return rust.QueryParameterWrapper.fromAscii(value);
        case rust.CqlType.BigInt:
            return rust.QueryParameterWrapper.fromBigint(
                arbitraryValueToBigInt(value),
            );
        case rust.CqlType.Blob:
            return rust.QueryParameterWrapper.fromBlob(value);
        case rust.CqlType.Boolean:
            return rust.QueryParameterWrapper.fromBoolean(value);
        case rust.CqlType.Counter:
            return rust.QueryParameterWrapper.fromCounter(BigInt(value));
        case rust.CqlType.Date:
            if (!(value instanceof LocalDate))
                throw new TypeError(
                    "Expected LocalDate type to parse into Cql Date",
                );
            return rust.QueryParameterWrapper.fromLocalDate(
                value.getInternal(),
            );
        case rust.CqlType.Double:
            return rust.QueryParameterWrapper.fromDouble(value);
        case rust.CqlType.Duration:
            if (!(value instanceof Duration))
                throw new TypeError(
                    "Expected Duration type to parse into Cql Duration",
                );
            return rust.QueryParameterWrapper.fromDuration(value.getInternal());
        case rust.CqlType.Float:
            return rust.QueryParameterWrapper.fromFloat(value);
        case rust.CqlType.Int:
            ensureNumber(value);
            return rust.QueryParameterWrapper.fromInt(value);
        case rust.CqlType.Set:
            // TODO:
            // This is part of the datastax logic for encoding set.
            // Here, this way of providing set is not supported.
            /* if (
                this.encodingOptions.set &amp;&amp;
                value instanceof this.encodingOptions.set
            ) {
                const arr = [];
                value.forEach(function (x) {
                    arr.push(x);
                });
                return this.encodeList(arr, subtype);
            } */
            encodedElement = encodeListLike(value, type.getFirstSupportType());
            return rust.QueryParameterWrapper.fromSet(encodedElement);
        case rust.CqlType.Text:
            return rust.QueryParameterWrapper.fromText(value);
        case rust.CqlType.Timestamp:
            tmpElement = value;
            if (typeof value === "string") {
                value = new Date(value);
            }
            if (value instanceof Date) {
                // milliseconds since epoch
                value = value.getTime();
                if (isNaN(value)) {
                    throw new TypeError("Invalid date: " + tmpElement);
                }
            }

            return rust.QueryParameterWrapper.fromTimestamp(BigInt(value));
        case rust.CqlType.Inet:
            // Other forms of providing InetAddress are kept as parity with old driver
            if (typeof value === "string") {
                value = InetAddress.fromString(value);
            } else if (value instanceof Buffer) {
                value = new InetAddress(value);
            }

            if (!(value instanceof InetAddress)) {
                throw new TypeError(
                    "Expected InetAddress type to parse into Cql Inet",
                );
            }
            return rust.QueryParameterWrapper.fromInet(value.getInternal());
        case rust.CqlType.List:
            encodedElement = encodeListLike(value, type.getFirstSupportType());
            return rust.QueryParameterWrapper.fromList(encodedElement);
        case rust.CqlType.Map:
            // TODO:
            // This is part of the datastax logic for encoding map.
            // Here, this way of providing map is not supported.
            /* if (
                this.encodingOptions.map &amp;&amp;
                value instanceof this.encodingOptions.map
            ) {
                // Use Map#forEach() method to iterate
                value.forEach(addItem);
            } */
            encodedElement = encodeMap(value, type);
            return rust.QueryParameterWrapper.fromMap(encodedElement);
        case rust.CqlType.SmallInt:
            ensureNumber(value);
            return rust.QueryParameterWrapper.fromSmallInt(value);
        case rust.CqlType.Time:
            // Other forms of providing LocalTime are kept as parity with old driver
            if (typeof value == "string") {
                value = LocalTime.fromString(value);
            }
            if (!(value instanceof LocalTime)) {
                throw new TypeError(
                    "Expected LocalTime type to parse into Cql Time",
                );
            }

            return rust.QueryParameterWrapper.fromLocalTime(
                value.getInternal(),
            );
        case rust.CqlType.TinyInt:
            ensureNumber(value);
            return rust.QueryParameterWrapper.fromTinyInt(value);
        case rust.CqlType.Uuid:
            // Other forms of providing UUID are kept as parity with old driver
            if (typeof value === "string") {
                value = Uuid.fromString(value);
            }

            if (!(value instanceof Uuid)) {
                throw new TypeError(
                    "Expected UUID type to parse into Cql Uuid",
                );
            }
            return rust.QueryParameterWrapper.fromUuid(value.getInternal());
        case rust.CqlType.Timeuuid:
            // Other forms of providing TimeUUID are kept as parity with old driver
            if (typeof value === "string") {
                value = TimeUuid.fromString(value);
            }
            if (!(value instanceof TimeUuid)) {
                throw new TypeError(
                    "Expected Time UUID type to parse into Cql Uuid",
                );
            }
            return rust.QueryParameterWrapper.fromTimeUuid(value.getInternal());
        default:
            // Or not yet implemented type
            throw new ReferenceError(
                `[INTERNAL DRIVER ERROR] Unknown type: ${type}`,
            );
    }
}

/**
 * Parses array of params into rust objects according to preparedStatement expected types
 * Throws ResponseError when received different amount of parameters than expected
 *
 * If ``allowGuessing`` is true, then for each missing field of ``expectedTypes``, this function will try to guess a type.
 * If the type cannot be guessed, error will be thrown.
 * Field is missing if it is null, undefined (or if the ``expectedTypes`` list is to short)
 * @param {Array&lt;rust.ComplexType | null>} expectedTypes List of expected types.
 * @param {Array&lt;any>} params
 * @param {boolean} [allowGuessing]
 * @returns {Array&lt;rust.QueryParameterWrapper>}
 */
function parseParams(expectedTypes, params, allowGuessing) {
    if (expectedTypes.length == 0 &amp;&amp; !params) return [];
    if (params.length != expectedTypes.length &amp;&amp; !allowGuessing) {
        throw new ResponseError(
            types.responseErrorCodes.invalid,
            `Expected ${expectedTypes.length}, got ${params.length} parameters.`,
        );
    }
    let res = [];
    for (let i = 0; i &lt; params.length; i++) {
        if (params[i] === types.unset) {
            // Rust driver works only with version >= 4 of CQL [Source?], so unset will always be supported.
            // Currently we don't support unset values and we treat them as NULL values.
            // TODO: Fix this
            params[i] = null;
        }

        if (params[i] === null) {
            res.push(null);
            continue;
        }

        let type = expectedTypes[i];
        if (!type &amp;&amp; allowGuessing) type = guessTypeChecked(params[i]);
        res.push(getWrapped(type, params[i]));
    }
    return res;
}

/**
 * Convert the hints from the formats allowed by the driver, to internal type representation
 * @param {Array&lt;string | number | object | null>} hints
 * @returns {Array&lt;rust.ComplexType | null>}
 */
function convertHints(hints) {
    let result = [];

    if (!Array.isArray(hints)) {
        return [];
    }

    for (const hint of hints) {
        if (hint) {
            /** @type {{code: Number, info: object}} */
            let objectHint = {
                code: null,
                info: null,
            };
            if (typeof hint === "number") {
                objectHint.code = hint;
            } else if (typeof hint === "string") {
                objectHint = types.dataTypes.getByName(hint);
            } else if (typeof hint.code === "number") {
                objectHint.code = hint.code;
                objectHint.info = hint.info;
            }
            if (typeof objectHint.code !== "number") {
                throw new TypeError(
                    "Type information not valid, only String and Number values are valid hints",
                );
            }
            result.push(rustConvertHint(objectHint));
        } else {
            result.push(null);
        }
    }
    return result;
}

/**
 *
 * @param {null | object | Array&lt;object>} object
 * @returns {rust.ComplexType | null}
 */
function rustConvertHint(object) {
    if (object.info &amp;&amp; !Array.isArray(object.info)) {
        object.info = [object.info];
    }
    return rust.convertHint(object);
}

module.exports.parseParams = parseParams;
module.exports.convertHints = convertHints;
module.exports.rustConvertHint = rustConvertHint;

// For unit test usage
module.exports.getWrapped = getWrapped;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-auth.html">auth</a></li><li><a href="module-concurrent.html">concurrent</a></li><li><a href="module-datastax.html">datastax</a></li><li><a href="module-errors.html">errors</a></li><li><a href="module-geometry.html">geometry</a></li><li><a href="module-mapping.html">mapping</a></li><li><a href="module-metadata.html">metadata</a></li><li><a href="module-metrics.html">metrics</a></li><li><a href="module-policies.html">policies</a></li><li><a href="module-policies_addressResolution.html">policies/addressResolution</a></li><li><a href="module-policies_loadBalancing.html">policies/loadBalancing</a></li><li><a href="module-policies_reconnection.html">policies/reconnection</a></li><li><a href="module-policies_retry.html">policies/retry</a></li><li><a href="module-policies_speculativeExecution.html">policies/speculativeExecution</a></li><li><a href="module-policies_timestampGeneration.html">policies/timestampGeneration</a></li><li><a href="module-tracker.html">tracker</a></li><li><a href="module-types.html">types</a></li></ul><h3>Classes</h3><ul><li><a href="AddressResolver.html">AddressResolver</a></li><li><a href="AuthResponseRequest.html">AuthResponseRequest</a></li><li><a href="BatchRequest.html">BatchRequest</a></li><li><a href="ByteOrderedToken.html">ByteOrderedToken</a></li><li><a href="Client.html">Client</a></li><li><a href="Connection.html">Connection</a></li><li><a href="ControlConnection.html">ControlConnection</a></li><li><a href="CredentialsRequest.html">CredentialsRequest</a></li><li><a href="Encoder.html">Encoder</a></li><li><a href="ExecuteRequest.html">ExecuteRequest</a></li><li><a href="ExecutionOptions.html">ExecutionOptions</a></li><li><a href="ExecutionProfile.html">ExecutionProfile</a></li><li><a href="FrameReader.html">FrameReader</a></li><li><a href="FrameWriter.html">FrameWriter</a></li><li><a href="HashSet.html">HashSet</a></li><li><a href="Host.html">Host</a></li><li><a href="HostConnectionPool.html">HostConnectionPool</a></li><li><a href="HostMap.html">HostMap</a></li><li><a href="LineString.html">LineString</a></li><li><a href="Murmur3Token.html">Murmur3Token</a></li><li><a href="Murmur3Tokenizer.html">Murmur3Tokenizer</a></li><li><a href="OperationState.html">OperationState</a></li><li><a href="Point.html">Point</a></li><li><a href="Polygon.html">Polygon</a></li><li><a href="PrepareHandler.html">PrepareHandler</a></li><li><a href="QueryRequest.html">QueryRequest</a></li><li><a href="RandomToken.html">RandomToken</a></li><li><a href="RandomTokenizer.html">RandomTokenizer</a></li><li><a href="Request.html">Request</a></li><li><a href="RequestExecution.html">RequestExecution</a></li><li><a href="RequestHandler.html">RequestHandler</a></li><li><a href="StartupRequest.html">StartupRequest</a></li><li><a href="StreamIdStack.html">StreamIdStack</a></li><li><a href="Token.html">Token</a></li><li><a href="TokenRange.html">TokenRange</a></li><li><a href="Tokenizer.html">Tokenizer</a></li><li><a href="TransitionalModePlainTextAuthenticator.html">TransitionalModePlainTextAuthenticator</a></li><li><a href="WriteQueue.html">WriteQueue</a></li><li><a href="module-auth-AuthProvider.html">AuthProvider</a></li><li><a href="module-auth-Authenticator.html">Authenticator</a></li><li><a href="module-auth-PlainTextAuthProvider.html">PlainTextAuthProvider</a></li><li><a href="module-errors-ArgumentError.html">ArgumentError</a></li><li><a href="module-errors-AuthenticationError.html">AuthenticationError</a></li><li><a href="module-errors-BusyConnectionError.html">BusyConnectionError</a></li><li><a href="module-errors-DriverInternalError.html">DriverInternalError</a></li><li><a href="module-errors-NoHostAvailableError.html">NoHostAvailableError</a></li><li><a href="module-errors-NotSupportedError.html">NotSupportedError</a></li><li><a href="module-errors-OperationTimedOutError.html">OperationTimedOutError</a></li><li><a href="module-errors-ResponseError.html">ResponseError</a></li><li><a href="module-mapping-DefaultTableMappings.html">DefaultTableMappings</a></li><li><a href="module-mapping-Mapper.html">Mapper</a></li><li><a href="module-mapping-ModelBatchItem.html">ModelBatchItem</a></li><li><a href="module-mapping-ModelMapper.html">ModelMapper</a></li><li><a href="module-mapping-Result.html">Result</a></li><li><a href="module-mapping-UnderscoreCqlToCamelCaseMappings.html">UnderscoreCqlToCamelCaseMappings</a></li><li><a href="module-metadata-Aggregate.html">Aggregate</a></li><li><a href="module-metadata-ClientState.html">ClientState</a></li><li><a href="module-metadata-DataCollection.html">DataCollection</a></li><li><a href="module-metadata-Index.html">Index</a></li><li><a href="module-metadata-MaterializedView.html">MaterializedView</a></li><li><a href="module-metadata-Metadata.html">Metadata</a></li><li><a href="module-metadata-SchemaFunction.html">SchemaFunction</a></li><li><a href="module-metadata-TableMetadata.html">TableMetadata</a></li><li><a href="module-metrics-DefaultMetrics.html">DefaultMetrics</a></li><li><a href="module-policies_addressResolution-AddressTranslator.html">AddressTranslator</a></li><li><a href="module-policies_addressResolution-EC2MultiRegionTranslator.html">EC2MultiRegionTranslator</a></li><li><a href="module-policies_loadBalancing-AllowListPolicy.html">AllowListPolicy</a></li><li><a href="module-policies_loadBalancing-DCAwareRoundRobinPolicy.html">DCAwareRoundRobinPolicy</a></li><li><a href="module-policies_loadBalancing-DefaultLoadBalancingPolicy.html">DefaultLoadBalancingPolicy</a></li><li><a href="module-policies_loadBalancing-LoadBalancingPolicy.html">LoadBalancingPolicy</a></li><li><a href="module-policies_loadBalancing-RoundRobinPolicy.html">RoundRobinPolicy</a></li><li><a href="module-policies_loadBalancing-TokenAwarePolicy.html">TokenAwarePolicy</a></li><li><a href="module-policies_loadBalancing-WhiteListPolicy.html">WhiteListPolicy</a></li><li><a href="module-policies_reconnection-ConstantReconnectionPolicy.html">ConstantReconnectionPolicy</a></li><li><a href="module-policies_reconnection-ExponentialReconnectionPolicy.html">ExponentialReconnectionPolicy</a></li><li><a href="module-policies_reconnection-ReconnectionPolicy.html">ReconnectionPolicy</a></li><li><a href="module-policies_retry-FallthroughRetryPolicy.html">FallthroughRetryPolicy</a></li><li><a href="module-policies_retry-IdempotenceAwareRetryPolicy.html">IdempotenceAwareRetryPolicy</a></li><li><a href="module-policies_retry-RetryPolicy.html">RetryPolicy</a></li><li><a href="module-policies_speculativeExecution-ConstantSpeculativeExecutionPolicy.html">ConstantSpeculativeExecutionPolicy</a></li><li><a href="module-policies_speculativeExecution-NoSpeculativeExecutionPolicy.html">NoSpeculativeExecutionPolicy</a></li><li><a href="module-policies_speculativeExecution-SpeculativeExecutionPolicy.html">SpeculativeExecutionPolicy</a></li><li><a href="module-policies_timestampGeneration-MonotonicTimestampGenerator.html">MonotonicTimestampGenerator</a></li><li><a href="module-policies_timestampGeneration-TimestampGenerator.html">TimestampGenerator</a></li><li><a href="module-tracker-RequestLogger.html">RequestLogger</a></li><li><a href="module-types-BigDecimal.html">BigDecimal</a></li><li><a href="module-types-Duration.html">Duration</a></li><li><a href="module-types-InetAddress.html">InetAddress</a></li><li><a href="module-types-Integer.html">Integer</a></li><li><a href="module-types-LocalDate.html">LocalDate</a></li><li><a href="module-types-LocalTime.html">LocalTime</a></li><li><a href="module-types-Long.html">Long</a></li><li><a href="module-types-ResultSet.html">ResultSet</a></li><li><a href="module-types-ResultStream.html">ResultStream</a></li><li><a href="module-types-Row.html">Row</a></li><li><a href="module-types-TimeUuid.html">TimeUuid</a></li><li><a href="module-types-Tuple.html">Tuple</a></li><li><a href="module-types-Uuid.html">Uuid</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-mapping-TableMappings.html">TableMappings</a></li><li><a href="module-metrics-ClientMetrics.html">ClientMetrics</a></li><li><a href="module-tracker-RequestTracker.html">RequestTracker</a></li></ul><h3>Events</h3><ul><li><a href="Client.html#event:hostAdd">hostAdd</a></li><li><a href="Client.html#event:hostDown">hostDown</a></li><li><a href="Client.html#event:hostRemove">hostRemove</a></li><li><a href="Client.html#event:hostUp">hostUp</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Integer">Integer</a></li><li><a href="global.html#Parser">Parser</a></li><li><a href="global.html#Protocol">Protocol</a></li><li><a href="global.html#ResultEmitter">ResultEmitter</a></li><li><a href="global.html#adaptNamedParamsPrepared">adaptNamedParamsPrepared</a></li><li><a href="global.html#adaptNamedParamsWithHints">adaptNamedParamsWithHints</a></li><li><a href="global.html#allocBuffer">allocBuffer</a></li><li><a href="global.html#allocBufferFromArray">allocBufferFromArray</a></li><li><a href="global.html#allocBufferFromString">allocBufferFromString</a></li><li><a href="global.html#allocBufferUnsafe">allocBufferUnsafe</a></li><li><a href="global.html#arbitraryValueToBigInt">arbitraryValueToBigInt</a></li><li><a href="global.html#arrayIterator">arrayIterator</a></li><li><a href="global.html#bigintToLong">bigintToLong</a></li><li><a href="global.html#binarySearch">binarySearch</a></li><li><a href="global.html#callbackOnce">callbackOnce</a></li><li><a href="global.html#convertHints">convertHints</a></li><li><a href="global.html#copyBuffer">copyBuffer</a></li><li><a href="global.html#coreConnectionsPerHostV2">coreConnectionsPerHostV2</a></li><li><a href="global.html#coreConnectionsPerHostV3">coreConnectionsPerHostV3</a></li><li><a href="global.html#deepExtend">deepExtend</a></li><li><a href="global.html#defaultOptions">defaultOptions</a></li><li><a href="global.html#defaultPromiseFactory">defaultPromiseFactory</a></li><li><a href="global.html#defaultReleaseDelay">defaultReleaseDelay</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#each">each</a></li><li><a href="global.html#eachSeries">eachSeries</a></li><li><a href="global.html#emptyArray">emptyArray</a></li><li><a href="global.html#emptyObject">emptyObject</a></li><li><a href="global.html#encodeListLike">encodeListLike</a></li><li><a href="global.html#encodeMap">encodeMap</a></li><li><a href="global.html#encodeVector">encodeVector</a></li><li><a href="global.html#ensureNumber">ensureNumber</a></li><li><a href="global.html#ensureValue">ensureValue</a></li><li><a href="global.html#errorCodes">errorCodes</a></li><li><a href="global.html#extend">extend</a></li><li><a href="global.html#fixStack">fixStack</a></li><li><a href="global.html#forEachOf">forEachOf</a></li><li><a href="global.html#fromCallback">fromCallback</a></li><li><a href="global.html#fromEvent">fromEvent</a></li><li><a href="global.html#fromSignedByte">fromSignedByte</a></li><li><a href="global.html#getCallback">getCallback</a></li><li><a href="global.html#getColumnsMetadata">getColumnsMetadata</a></li><li><a href="global.html#getCqlObject">getCqlObject</a></li><li><a href="global.html#getDefaultOptions">getDefaultOptions</a></li><li><a href="global.html#getRowsFromResultsWrapper">getRowsFromResultsWrapper</a></li><li><a href="global.html#getWrapped">getWrapped</a></li><li><a href="global.html#groupSize">groupSize</a></li><li><a href="global.html#guessTypeChecked">guessTypeChecked</a></li><li><a href="global.html#ifUndefined">ifUndefined</a></li><li><a href="global.html#ifUndefined3">ifUndefined3</a></li><li><a href="global.html#insertSorted">insertSorted</a></li><li><a href="global.html#iteratorToArray">iteratorToArray</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#longToBigint">longToBigint</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#mapSeries">mapSeries</a></li><li><a href="global.html#maxGroupsFor2Bytes">maxGroupsFor2Bytes</a></li><li><a href="global.html#maxInt">maxInt</a></li><li><a href="global.html#maxRequestsPerConnectionV2">maxRequestsPerConnectionV2</a></li><li><a href="global.html#maxRequestsPerConnectionV3">maxRequestsPerConnectionV3</a></li><li><a href="global.html#napiErrorHandler">napiErrorHandler</a></li><li><a href="global.html#newQueryPlan">newQueryPlan</a></li><li><a href="global.html#objectValues">objectValues</a></li><li><a href="global.html#optionalCallback">optionalCallback</a></li><li><a href="global.html#parallel">parallel</a></li><li><a href="global.html#parseParams">parseParams</a></li><li><a href="global.html#parseVectorTypeArgs">parseVectorTypeArgs</a></li><li><a href="global.html#promiseWrapper">promiseWrapper</a></li><li><a href="global.html#queryOptionsIntoWrapper">queryOptionsIntoWrapper</a></li><li><a href="global.html#releasableSize">releasableSize</a></li><li><a href="global.html#resultFlag">resultFlag</a></li><li><a href="global.html#rowBuffer">rowBuffer</a></li><li><a href="global.html#rustConvertHint">rustConvertHint</a></li><li><a href="global.html#series">series</a></li><li><a href="global.html#setMetadataDependent">setMetadataDependent</a></li><li><a href="global.html#shiftToGroup">shiftToGroup</a></li><li><a href="global.html#stringRepeat">stringRepeat</a></li><li><a href="global.html#throwNotSupported">throwNotSupported</a></li><li><a href="global.html#times">times</a></li><li><a href="global.html#timesLimit">timesLimit</a></li><li><a href="global.html#timesSeries">timesSeries</a></li><li><a href="global.html#toBackground">toBackground</a></li><li><a href="global.html#toCallback">toCallback</a></li><li><a href="global.html#toLowerCaseProperties">toLowerCaseProperties</a></li><li><a href="global.html#totalLength">totalLength</a></li><li><a href="global.html#validateFn">validateFn</a></li><li><a href="global.html#whilst">whilst</a></li><li><a href="global.html#wrapValueBasedOnType">wrapValueBasedOnType</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Apr 08 2025 11:50:06 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
