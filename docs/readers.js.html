<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: readers.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: readers.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

const util = require("util");
const utils = require("./utils");
const types = require("./types");
const errors = require("./errors");

/**
 * Information on the formatting of the returned rows
 */
const resultFlag = {
    globalTablesSpec: 0x0001,
    hasMorePages: 0x0002,
    noMetadata: 0x0004,
    metadataChanged: 0x0008,
    continuousPaging: 0x40000000,
    lastContinuousPage: 0x80000000,
};

// templates for derived error messages.
const _writeTimeoutQueryMessage =
    "Server timeout during write query at consistency %s (%d peer(s) acknowledged the write over %d required)";
const _writeTimeoutBatchLogMessage =
    "Server timeout during batchlog write at consistency %s (%d peer(s) acknowledged the write over %d required)";
const _writeFailureMessage =
    "Server failure during write query at consistency %s (%d responses were required but only %d replicas responded, %d failed)";
const _unavailableMessage =
    "Not enough replicas available for query at consistency %s (%d required but only %d alive)";
const _readTimeoutMessage =
    "Server timeout during read query at consistency %s (%s)";
const _readFailureMessage =
    "Server failure during read query at consistency %s (%d responses were required but only %d replicas responded, %d failed)";

/**
 * Buffer forward reader of CQL binary frames
 * @param {FrameHeader} header
 * @param {Buffer} body
 * @param {Number} [offset]
 */
class FrameReader {
    /**
     * Creates a new instance of the reader
     * @param {FrameHeader} header
     * @param {Buffer} body
     * @param {Number} [offset]
     */
    constructor(header, body, offset) {
        this.header = header;
        this.opcode = header.opcode;
        this.offset = offset || 0;
        this.buf = body;
    }

    remainingLength() {
        return this.buf.length - this.offset;
    }

    getBuffer() {
        return this.buf;
    }

    /**
     * Slices the underlining buffer
     * @param {Number} begin
     * @param {Number} [end]
     * @returns {Buffer}
     */
    slice(begin, end) {
        if (typeof end === "undefined") {
            end = this.buf.length;
        }
        return this.buf.slice(begin, end);
    }

    /**
     * Modifies the underlying buffer, it concatenates the given buffer with the original (internalBuffer = concat(bytes, internalBuffer)
     */
    unshift(bytes) {
        if (this.offset > 0) {
            throw new Error(
                "Can not modify the underlying buffer if already read",
            );
        }
        this.buf = Buffer.concat(
            [bytes, this.buf],
            bytes.length + this.buf.length,
        );
    }

    /**
     * Reads any number of bytes and moves the offset.
     * if length not provided or it's larger than the remaining bytes, reads to end.
     * @param length
     * @returns {Buffer}
     */
    read(length) {
        let end = this.buf.length;
        if (
            typeof length !== "undefined" &amp;&amp;
            this.offset + length &lt; this.buf.length
        ) {
            end = this.offset + length;
        }
        const bytes = this.slice(this.offset, end);
        this.offset = end;
        return bytes;
    }

    /**
     * Moves the reader cursor to the end
     */
    toEnd() {
        this.offset = this.buf.length;
    }

    /**
     * Reads a BE Int and moves the offset
     * @returns {Number}
     */
    readInt() {
        const result = this.buf.readInt32BE(this.offset);
        this.offset += 4;
        return result;
    }

    /** @returns {Number} */
    readShort() {
        const result = this.buf.readUInt16BE(this.offset);
        this.offset += 2;
        return result;
    }

    readByte() {
        const result = this.buf.readUInt8(this.offset);
        this.offset += 1;
        return result;
    }

    readString() {
        const length = this.readShort();
        this.checkOffset(length);
        const result = this.buf.toString(
            "utf8",
            this.offset,
            this.offset + length,
        );
        this.offset += length;
        return result;
    }

    /**
     * Checks that the new length to read is within the range of the buffer length. Throws a RangeError if not.
     * @param {Number} newLength
     */
    checkOffset(newLength) {
        if (this.offset + newLength > this.buf.length) {
            const err = new RangeError("Trying to access beyond buffer length");
            err.expectedLength = newLength;
            throw err;
        }
    }

    /**
     * Reads a protocol string list
     * @returns {Array}
     */
    readStringList() {
        const length = this.readShort();
        const list = new Array(length);
        for (let i = 0; i &lt; length; i++) {
            list[i] = this.readString();
        }
        return list;
    }

    /**
     * Reads the amount of bytes that the field has and returns them (slicing them).
     * @returns {Buffer}
     */
    readBytes() {
        const length = this.readInt();
        if (length &lt; 0) {
            return null;
        }
        this.checkOffset(length);
        return this.read(length);
    }

    readShortBytes() {
        const length = this.readShort();
        if (length &lt; 0) {
            return null;
        }
        this.checkOffset(length);
        return this.read(length);
    }

    /**
     * Reads an associative array of strings as keys and bytes as values
     * @param {Number} length
     * @param {Function} keyFn
     * @param {Function} valueFn
     * @returns {Object}
     */
    readMap(length, keyFn, valueFn) {
        if (length &lt; 0) {
            return null;
        }
        const map = {};
        for (let i = 0; i &lt; length; i++) {
            map[keyFn.call(this)] = valueFn.call(this);
        }
        return map;
    }

    /**
     * Reads an associative array of strings as keys and string lists as values
     * @returns {Object}
     */
    readStringMultiMap() {
        // A [short] n, followed by n pair &lt;k>&lt;v> where &lt;k> is a
        // [string] and &lt;v> is a [string[]].
        const length = this.readShort();
        if (length &lt; 0) {
            return null;
        }
        const map = {};
        for (let i = 0; i &lt; length; i++) {
            map[this.readString()] = this.readStringList();
        }
        return map;
    }

    /**
     * Reads a data type definition
     * @returns {{code: Number, info: Object|null}} An array of 2 elements
     */
    readType() {
        let i;
        const type = {
            code: this.readShort(),
            type: null,
        };
        switch (type.code) {
            case types.dataTypes.custom:
                type.info = this.readString();
                break;
            case types.dataTypes.list:
            case types.dataTypes.set:
                type.info = this.readType();
                break;
            case types.dataTypes.map:
                type.info = [this.readType(), this.readType()];
                break;
            case types.dataTypes.udt:
                type.info = {
                    keyspace: this.readString(),
                    name: this.readString(),
                    fields: new Array(this.readShort()),
                };
                for (i = 0; i &lt; type.info.fields.length; i++) {
                    type.info.fields[i] = {
                        name: this.readString(),
                        type: this.readType(),
                    };
                }
                break;
            case types.dataTypes.tuple:
                type.info = new Array(this.readShort());
                for (i = 0; i &lt; type.info.length; i++) {
                    type.info[i] = this.readType();
                }
                break;
        }
        return type;
    }

    /**
     * Reads an Ip address and port
     * @returns {{address: exports.InetAddress, port: Number}}
     */
    readInet() {
        const length = this.readByte();
        const address = this.read(length);
        return {
            address: new types.InetAddress(address),
            port: this.readInt(),
        };
    }

    /**
     * Reads an Ip address
     * @returns {InetAddress}
     */
    readInetAddress() {
        const length = this.readByte();
        return new types.InetAddress(this.read(length));
    }

    /**
     * Reads the body bytes corresponding to the flags
     * @returns {{traceId: Uuid, warnings: Array, customPayload}}
     * @throws {RangeError}
     */
    readFlagsInfo() {
        if (this.header.flags === 0) {
            return utils.emptyObject;
        }
        const result = {};
        if (this.header.flags &amp; types.frameFlags.tracing) {
            this.checkOffset(16);
            result.traceId = new types.Uuid(utils.copyBuffer(this.read(16)));
        }
        if (this.header.flags &amp; types.frameFlags.warning) {
            result.warnings = this.readStringList();
        }
        if (this.header.flags &amp; types.frameFlags.customPayload) {
            // Custom payload is a Map&lt;string, Buffer>
            result.customPayload = this.readMap(
                this.readShort(),
                this.readString,
                this.readBytes,
            );
        }
        return result;
    }

    /**
     * Reads the metadata from a row or a prepared result response
     * @param {Number} kind
     * @returns {Object}
     * @throws {RangeError}
     */
    readMetadata(kind) {
        let i;
        // Determines if its a prepared metadata
        const isPrepared = kind === types.resultKind.prepared;
        const meta = {};
        if (
            types.protocolVersion.supportsResultMetadataId(
                this.header.version,
            ) &amp;&amp;
            isPrepared
        ) {
            meta.resultId = utils.copyBuffer(this.readShortBytes());
        }
        // as used in Rows and Prepared responses
        const flags = this.readInt();
        const columnLength = this.readInt();
        if (
            types.protocolVersion.supportsPreparedPartitionKey(
                this.header.version,
            ) &amp;&amp;
            isPrepared
        ) {
            // read the pk columns
            meta.partitionKeys = new Array(this.readInt());
            for (i = 0; i &lt; meta.partitionKeys.length; i++) {
                meta.partitionKeys[i] = this.readShort();
            }
        }
        if (flags &amp; resultFlag.hasMorePages) {
            meta.pageState = utils.copyBuffer(this.readBytes());
        }
        if (flags &amp; resultFlag.metadataChanged) {
            meta.newResultId = utils.copyBuffer(this.readShortBytes());
        }
        if (flags &amp; resultFlag.continuousPaging) {
            meta.continuousPageIndex = this.readInt();
            meta.lastContinuousPage = !!(flags &amp; resultFlag.lastContinuousPage);
        }
        if (flags &amp; resultFlag.globalTablesSpec) {
            meta.global_tables_spec = true; // eslint-disable-line camelcase
            meta.keyspace = this.readString();
            meta.table = this.readString();
        }
        meta.columns = new Array(columnLength);
        meta.columnsByName = utils.emptyObject;
        if (isPrepared) {
            // for prepared metadata, we will need a index of the columns (param) by name
            meta.columnsByName = {};
        }
        for (i = 0; i &lt; columnLength; i++) {
            const col = {};
            if (!meta.global_tables_spec) {
                col.ksname = this.readString();
                col.tablename = this.readString();
            }
            col.name = this.readString();
            col.type = this.readType();
            meta.columns[i] = col;
            if (isPrepared) {
                meta.columnsByName[col.name] = i;
            }
        }
        return meta;
    }

    /**
     * Reads the error from the frame
     * @throws {RangeError}
     * @returns {ResponseError}
     */
    readError() {
        const code = this.readInt();
        const message = this.readString();
        const err = new errors.ResponseError(code, message);
        // read extra info
        switch (code) {
            case types.responseErrorCodes.unavailableException:
                err.consistencies = this.readShort();
                err.required = this.readInt();
                err.alive = this.readInt();
                err.message = util.format(
                    _unavailableMessage,
                    types.consistencyToString[err.consistencies],
                    err.required,
                    err.alive,
                );
                break;
            case types.responseErrorCodes.readTimeout:
            case types.responseErrorCodes.readFailure:
                err.consistencies = this.readShort();
                err.received = this.readInt();
                err.blockFor = this.readInt();
                if (code === types.responseErrorCodes.readFailure) {
                    if (
                        types.protocolVersion.supportsFailureReasonMap(
                            this.header.version,
                        )
                    ) {
                        err.failures = this.readInt();
                        err.reasons = this.readMap(
                            err.failures,
                            this.readInetAddress,
                            this.readShort,
                        );
                    } else {
                        err.failures = this.readInt();
                    }
                }
                err.isDataPresent = this.readByte();
                if (code === types.responseErrorCodes.readTimeout) {
                    let details;
                    if (err.received &lt; err.blockFor) {
                        details = util.format(
                            "%d replica(s) responded over %d required",
                            err.received,
                            err.blockFor,
                        );
                    } else if (!err.isDataPresent) {
                        details =
                            "the replica queried for the data didn't respond";
                    } else {
                        details =
                            "timeout while waiting for repair of inconsistent replica";
                    }
                    err.message = util.format(
                        _readTimeoutMessage,
                        types.consistencyToString[err.consistencies],
                        details,
                    );
                } else {
                    err.message = util.format(
                        _readFailureMessage,
                        types.consistencyToString[err.consistencies],
                        err.blockFor,
                        err.received,
                        err.failures,
                    );
                }
                break;
            case types.responseErrorCodes.writeTimeout:
            case types.responseErrorCodes.writeFailure:
                err.consistencies = this.readShort();
                err.received = this.readInt();
                err.blockFor = this.readInt();
                if (code === types.responseErrorCodes.writeFailure) {
                    if (
                        types.protocolVersion.supportsFailureReasonMap(
                            this.header.version,
                        )
                    ) {
                        err.failures = this.readInt();
                        err.reasons = this.readMap(
                            err.failures,
                            this.readInetAddress,
                            this.readShort,
                        );
                    } else {
                        err.failures = this.readInt();
                    }
                }
                err.writeType = this.readString();
                if (code === types.responseErrorCodes.writeTimeout) {
                    const template =
                        err.writeType === "BATCH_LOG"
                            ? _writeTimeoutBatchLogMessage
                            : _writeTimeoutQueryMessage;
                    err.message = util.format(
                        template,
                        types.consistencyToString[err.consistencies],
                        err.received,
                        err.blockFor,
                    );
                } else {
                    err.message = util.format(
                        _writeFailureMessage,
                        types.consistencyToString[err.consistencies],
                        err.blockFor,
                        err.received,
                        err.failures,
                    );
                }
                break;
            case types.responseErrorCodes.unprepared:
                err.queryId = utils.copyBuffer(this.readShortBytes());
                break;
            case types.responseErrorCodes.functionFailure:
                err.keyspace = this.readString();
                err.functionName = this.readString();
                err.argTypes = this.readStringList();
                break;
            case types.responseErrorCodes.alreadyExists: {
                err.keyspace = this.readString();
                const table = this.readString();
                if (table.length > 0) {
                    err.table = table;
                }
                break;
            }
        }
        return err;
    }

    /**
     * Reads an event from Cassandra and returns the detail
     * @returns {{eventType: String, inet: {address: Buffer, port: Number} | undefined,
     * added: Boolean | undefined, up: Boolean | undefined}}
     */
    readEvent() {
        const eventType = this.readString();
        switch (eventType) {
            case types.protocolEvents.topologyChange:
                return {
                    added: this.readString() === "NEW_NODE",
                    inet: this.readInet(),
                    eventType: eventType,
                };
            case types.protocolEvents.statusChange:
                return {
                    up: this.readString() === "UP",
                    inet: this.readInet(),
                    eventType: eventType,
                };
            case types.protocolEvents.schemaChange:
                return this.parseSchemaChange();
        }
        // Forward compatibility
        return { eventType: eventType };
    }

    parseSchemaChange() {
        let result;
        if (
            !types.protocolVersion.supportsSchemaChangeFullMetadata(
                this.header.version,
            )
        ) {
            // v1/v2: 3 strings, the table value can be empty
            result = {
                eventType: types.protocolEvents.schemaChange,
                schemaChangeType: this.readString(),
                keyspace: this.readString(),
                table: this.readString(),
            };
            result.isKeyspace = !result.table;
            return result;
        }
        // v3+: 3 or 4 strings: change_type, target, keyspace and (table, type, functionName or aggregate)
        result = {
            eventType: types.protocolEvents.schemaChange,
            schemaChangeType: this.readString(),
            target: this.readString(),
            keyspace: this.readString(),
            table: null,
            udt: null,
            signature: null,
        };
        result.isKeyspace = result.target === "KEYSPACE";
        switch (result.target) {
            case "TABLE":
                result.table = this.readString();
                break;
            case "TYPE":
                result.udt = this.readString();
                break;
            case "FUNCTION":
                result.functionName = this.readString();
                result.signature = this.readStringList();
                break;
            case "AGGREGATE":
                result.aggregate = this.readString();
                result.signature = this.readStringList();
        }
        return result;
    }
}

module.exports = { FrameReader };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-auth.html">auth</a></li><li><a href="module-concurrent.html">concurrent</a></li><li><a href="module-datastax.html">datastax</a></li><li><a href="module-errors.html">errors</a></li><li><a href="module-geometry.html">geometry</a></li><li><a href="module-mapping.html">mapping</a></li><li><a href="module-metadata.html">metadata</a></li><li><a href="module-metrics.html">metrics</a></li><li><a href="module-policies.html">policies</a></li><li><a href="module-policies_addressResolution.html">policies/addressResolution</a></li><li><a href="module-policies_loadBalancing.html">policies/loadBalancing</a></li><li><a href="module-policies_reconnection.html">policies/reconnection</a></li><li><a href="module-policies_retry.html">policies/retry</a></li><li><a href="module-policies_speculativeExecution.html">policies/speculativeExecution</a></li><li><a href="module-policies_timestampGeneration.html">policies/timestampGeneration</a></li><li><a href="module-tracker.html">tracker</a></li><li><a href="module-types.html">types</a></li></ul><h3>Classes</h3><ul><li><a href="AddressResolver.html">AddressResolver</a></li><li><a href="AuthResponseRequest.html">AuthResponseRequest</a></li><li><a href="BatchRequest.html">BatchRequest</a></li><li><a href="ByteOrderedToken.html">ByteOrderedToken</a></li><li><a href="Client.html">Client</a></li><li><a href="Connection.html">Connection</a></li><li><a href="ControlConnection.html">ControlConnection</a></li><li><a href="CredentialsRequest.html">CredentialsRequest</a></li><li><a href="Encoder.html">Encoder</a></li><li><a href="ExecuteRequest.html">ExecuteRequest</a></li><li><a href="ExecutionOptions.html">ExecutionOptions</a></li><li><a href="ExecutionProfile.html">ExecutionProfile</a></li><li><a href="FrameReader.html">FrameReader</a></li><li><a href="FrameWriter.html">FrameWriter</a></li><li><a href="HashSet.html">HashSet</a></li><li><a href="Host.html">Host</a></li><li><a href="HostConnectionPool.html">HostConnectionPool</a></li><li><a href="HostMap.html">HostMap</a></li><li><a href="InsightsClient.html">InsightsClient</a></li><li><a href="LineString.html">LineString</a></li><li><a href="Murmur3Token.html">Murmur3Token</a></li><li><a href="Murmur3Tokenizer.html">Murmur3Tokenizer</a></li><li><a href="OperationState.html">OperationState</a></li><li><a href="Point.html">Point</a></li><li><a href="Polygon.html">Polygon</a></li><li><a href="PrepareHandler.html">PrepareHandler</a></li><li><a href="QueryRequest.html">QueryRequest</a></li><li><a href="RandomToken.html">RandomToken</a></li><li><a href="RandomTokenizer.html">RandomTokenizer</a></li><li><a href="Request.html">Request</a></li><li><a href="RequestExecution.html">RequestExecution</a></li><li><a href="RequestHandler.html">RequestHandler</a></li><li><a href="StartupRequest.html">StartupRequest</a></li><li><a href="StreamIdStack.html">StreamIdStack</a></li><li><a href="Token.html">Token</a></li><li><a href="TokenRange.html">TokenRange</a></li><li><a href="Tokenizer.html">Tokenizer</a></li><li><a href="TransitionalModePlainTextAuthenticator.html">TransitionalModePlainTextAuthenticator</a></li><li><a href="WriteQueue.html">WriteQueue</a></li><li><a href="module-auth-AuthProvider.html">AuthProvider</a></li><li><a href="module-auth-Authenticator.html">Authenticator</a></li><li><a href="module-auth-DseGssapiAuthProvider.html">DseGssapiAuthProvider</a></li><li><a href="module-auth-DsePlainTextAuthProvider.html">DsePlainTextAuthProvider</a></li><li><a href="module-auth-PlainTextAuthProvider.html">PlainTextAuthProvider</a></li><li><a href="module-errors-ArgumentError.html">ArgumentError</a></li><li><a href="module-errors-AuthenticationError.html">AuthenticationError</a></li><li><a href="module-errors-BusyConnectionError.html">BusyConnectionError</a></li><li><a href="module-errors-DriverInternalError.html">DriverInternalError</a></li><li><a href="module-errors-NoHostAvailableError.html">NoHostAvailableError</a></li><li><a href="module-errors-NotSupportedError.html">NotSupportedError</a></li><li><a href="module-errors-OperationTimedOutError.html">OperationTimedOutError</a></li><li><a href="module-errors-ResponseError.html">ResponseError</a></li><li><a href="module-mapping-DefaultTableMappings.html">DefaultTableMappings</a></li><li><a href="module-mapping-Mapper.html">Mapper</a></li><li><a href="module-mapping-ModelBatchItem.html">ModelBatchItem</a></li><li><a href="module-mapping-ModelMapper.html">ModelMapper</a></li><li><a href="module-mapping-Result.html">Result</a></li><li><a href="module-mapping-UnderscoreCqlToCamelCaseMappings.html">UnderscoreCqlToCamelCaseMappings</a></li><li><a href="module-metadata-Aggregate.html">Aggregate</a></li><li><a href="module-metadata-ClientState.html">ClientState</a></li><li><a href="module-metadata-DataCollection.html">DataCollection</a></li><li><a href="module-metadata-Index.html">Index</a></li><li><a href="module-metadata-MaterializedView.html">MaterializedView</a></li><li><a href="module-metadata-Metadata.html">Metadata</a></li><li><a href="module-metadata-SchemaFunction.html">SchemaFunction</a></li><li><a href="module-metadata-TableMetadata.html">TableMetadata</a></li><li><a href="module-metrics-DefaultMetrics.html">DefaultMetrics</a></li><li><a href="module-policies_addressResolution-AddressTranslator.html">AddressTranslator</a></li><li><a href="module-policies_addressResolution-EC2MultiRegionTranslator.html">EC2MultiRegionTranslator</a></li><li><a href="module-policies_loadBalancing-AllowListPolicy.html">AllowListPolicy</a></li><li><a href="module-policies_loadBalancing-DCAwareRoundRobinPolicy.html">DCAwareRoundRobinPolicy</a></li><li><a href="module-policies_loadBalancing-DefaultLoadBalancingPolicy.html">DefaultLoadBalancingPolicy</a></li><li><a href="module-policies_loadBalancing-LoadBalancingPolicy.html">LoadBalancingPolicy</a></li><li><a href="module-policies_loadBalancing-RoundRobinPolicy.html">RoundRobinPolicy</a></li><li><a href="module-policies_loadBalancing-TokenAwarePolicy.html">TokenAwarePolicy</a></li><li><a href="module-policies_loadBalancing-WhiteListPolicy.html">WhiteListPolicy</a></li><li><a href="module-policies_reconnection-ConstantReconnectionPolicy.html">ConstantReconnectionPolicy</a></li><li><a href="module-policies_reconnection-ExponentialReconnectionPolicy.html">ExponentialReconnectionPolicy</a></li><li><a href="module-policies_reconnection-ReconnectionPolicy.html">ReconnectionPolicy</a></li><li><a href="module-policies_retry-FallthroughRetryPolicy.html">FallthroughRetryPolicy</a></li><li><a href="module-policies_retry-IdempotenceAwareRetryPolicy.html">IdempotenceAwareRetryPolicy</a></li><li><a href="module-policies_retry-RetryPolicy.html">RetryPolicy</a></li><li><a href="module-policies_speculativeExecution-ConstantSpeculativeExecutionPolicy.html">ConstantSpeculativeExecutionPolicy</a></li><li><a href="module-policies_speculativeExecution-NoSpeculativeExecutionPolicy.html">NoSpeculativeExecutionPolicy</a></li><li><a href="module-policies_speculativeExecution-SpeculativeExecutionPolicy.html">SpeculativeExecutionPolicy</a></li><li><a href="module-policies_timestampGeneration-MonotonicTimestampGenerator.html">MonotonicTimestampGenerator</a></li><li><a href="module-policies_timestampGeneration-TimestampGenerator.html">TimestampGenerator</a></li><li><a href="module-tracker-RequestLogger.html">RequestLogger</a></li><li><a href="module-types-BigDecimal.html">BigDecimal</a></li><li><a href="module-types-Duration.html">Duration</a></li><li><a href="module-types-InetAddress.html">InetAddress</a></li><li><a href="module-types-Integer.html">Integer</a></li><li><a href="module-types-LocalDate.html">LocalDate</a></li><li><a href="module-types-LocalTime.html">LocalTime</a></li><li><a href="module-types-Long.html">Long</a></li><li><a href="module-types-ResultSet.html">ResultSet</a></li><li><a href="module-types-ResultStream.html">ResultStream</a></li><li><a href="module-types-Row.html">Row</a></li><li><a href="module-types-TimeUuid.html">TimeUuid</a></li><li><a href="module-types-Tuple.html">Tuple</a></li><li><a href="module-types-Uuid.html">Uuid</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-mapping-TableMappings.html">TableMappings</a></li><li><a href="module-metrics-ClientMetrics.html">ClientMetrics</a></li><li><a href="module-tracker-RequestTracker.html">RequestTracker</a></li></ul><h3>Events</h3><ul><li><a href="Client.html#event:hostAdd">hostAdd</a></li><li><a href="Client.html#event:hostDown">hostDown</a></li><li><a href="Client.html#event:hostRemove">hostRemove</a></li><li><a href="Client.html#event:hostUp">hostUp</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Parser">Parser</a></li><li><a href="global.html#Protocol">Protocol</a></li><li><a href="global.html#ResultEmitter">ResultEmitter</a></li><li><a href="global.html#adaptNamedParamsPrepared">adaptNamedParamsPrepared</a></li><li><a href="global.html#adaptNamedParamsWithHints">adaptNamedParamsWithHints</a></li><li><a href="global.html#allocBuffer">allocBuffer</a></li><li><a href="global.html#allocBufferFromArray">allocBufferFromArray</a></li><li><a href="global.html#allocBufferFromString">allocBufferFromString</a></li><li><a href="global.html#allocBufferUnsafe">allocBufferUnsafe</a></li><li><a href="global.html#arrayIterator">arrayIterator</a></li><li><a href="global.html#binarySearch">binarySearch</a></li><li><a href="global.html#callbackOnce">callbackOnce</a></li><li><a href="global.html#copyBuffer">copyBuffer</a></li><li><a href="global.html#coreConnectionsPerHostV2">coreConnectionsPerHostV2</a></li><li><a href="global.html#coreConnectionsPerHostV3">coreConnectionsPerHostV3</a></li><li><a href="global.html#deepExtend">deepExtend</a></li><li><a href="global.html#defaultOptions">defaultOptions</a></li><li><a href="global.html#defaultPromiseFactory">defaultPromiseFactory</a></li><li><a href="global.html#defaultReleaseDelay">defaultReleaseDelay</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#each">each</a></li><li><a href="global.html#eachSeries">eachSeries</a></li><li><a href="global.html#emptyArray">emptyArray</a></li><li><a href="global.html#emptyObject">emptyObject</a></li><li><a href="global.html#encodeVector">encodeVector</a></li><li><a href="global.html#errorCodes">errorCodes</a></li><li><a href="global.html#extend">extend</a></li><li><a href="global.html#fixStack">fixStack</a></li><li><a href="global.html#forEachOf">forEachOf</a></li><li><a href="global.html#fromCallback">fromCallback</a></li><li><a href="global.html#fromEvent">fromEvent</a></li><li><a href="global.html#fromSignedByte">fromSignedByte</a></li><li><a href="global.html#getCallback">getCallback</a></li><li><a href="global.html#getDefaultOptions">getDefaultOptions</a></li><li><a href="global.html#groupSize">groupSize</a></li><li><a href="global.html#ifUndefined">ifUndefined</a></li><li><a href="global.html#ifUndefined3">ifUndefined3</a></li><li><a href="global.html#insertSorted">insertSorted</a></li><li><a href="global.html#iteratorToArray">iteratorToArray</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#mapSeries">mapSeries</a></li><li><a href="global.html#maxGroupsFor2Bytes">maxGroupsFor2Bytes</a></li><li><a href="global.html#maxInt">maxInt</a></li><li><a href="global.html#maxRequestsPerConnectionV2">maxRequestsPerConnectionV2</a></li><li><a href="global.html#maxRequestsPerConnectionV3">maxRequestsPerConnectionV3</a></li><li><a href="global.html#newQueryPlan">newQueryPlan</a></li><li><a href="global.html#objectValues">objectValues</a></li><li><a href="global.html#optionalCallback">optionalCallback</a></li><li><a href="global.html#parallel">parallel</a></li><li><a href="global.html#parseVectorTypeArgs">parseVectorTypeArgs</a></li><li><a href="global.html#promiseWrapper">promiseWrapper</a></li><li><a href="global.html#releasableSize">releasableSize</a></li><li><a href="global.html#resultFlag">resultFlag</a></li><li><a href="global.html#rowBuffer">rowBuffer</a></li><li><a href="global.html#series">series</a></li><li><a href="global.html#setMetadataDependent">setMetadataDependent</a></li><li><a href="global.html#shiftToGroup">shiftToGroup</a></li><li><a href="global.html#stringRepeat">stringRepeat</a></li><li><a href="global.html#throwNotSupported">throwNotSupported</a></li><li><a href="global.html#times">times</a></li><li><a href="global.html#timesLimit">timesLimit</a></li><li><a href="global.html#timesSeries">timesSeries</a></li><li><a href="global.html#toBackground">toBackground</a></li><li><a href="global.html#toCallback">toCallback</a></li><li><a href="global.html#toLowerCaseProperties">toLowerCaseProperties</a></li><li><a href="global.html#totalLength">totalLength</a></li><li><a href="global.html#validateFn">validateFn</a></li><li><a href="global.html#whilst">whilst</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun Nov 24 2024 15:06:54 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
