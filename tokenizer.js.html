<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: tokenizer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: tokenizer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

const types = require("./types");
const token = require("./token");
const utils = require("./utils");
const MutableLong = require("./types/mutable-long");
const { Integer } = types;

// Murmur3 constants
// -0x783C846EEEBDAC2B
const mconst1 = new MutableLong(0x53d5, 0x1142, 0x7b91, 0x87c3);
// 0x4cf5ad432745937f
const mconst2 = new MutableLong(0x937f, 0x2745, 0xad43, 0x4cf5);
const mlongFive = MutableLong.fromNumber(5);
// 0xff51afd7ed558ccd
const mconst3 = new MutableLong(0x8ccd, 0xed55, 0xafd7, 0xff51);
// 0xc4ceb9fe1a85ec53
const mconst4 = new MutableLong(0xec53, 0x1a85, 0xb9fe, 0xc4ce);
const mconst5 = MutableLong.fromNumber(0x52dce729);
const mconst6 = MutableLong.fromNumber(0x38495ab5);

/**
 * Represents a set of methods that are able to generate and parse tokens for the C* partitioner.
 * @abstract
 */
class Tokenizer {
    constructor() {}

    /**
     * Creates a token based on the Buffer value provided
     * @abstract
     * @param {Buffer|Array} value
     * @returns {Token} Computed token
     */
    hash(value) {
        throw new Error("You must implement a hash function for the tokenizer");
    }

    /**
     * Parses a token string and returns a representation of the token
     * @abstract
     * @param {String} value
     */
    parse(value) {
        throw new Error(
            "You must implement a parse function for the tokenizer",
        );
    }

    minToken() {
        throw new Error(
            "You must implement a minToken function for the tokenizer",
        );
    }

    /**
     * Splits the range specified by start and end into numberOfSplits equal parts.
     * @param {Token} start Starting token
     * @param {Token} end  End token
     * @param {Number} numberOfSplits Number of splits to make.
     */
    split(start, end, numberOfSplits) {
        throw new Error(
            "You must implement a split function for the tokenizer",
        );
    }

    /**
     * Common implementation for splitting token ranges when start is in
     * a shared Integer format.
     *
     * @param {Integer} start Starting token
     * @param {Integer} range How large the range of the split is
     * @param {Integer} ringEnd The end point of the ring so we know where to wrap
     * @param {Integer} ringLength The total size of the ring
     * @param {Number} numberOfSplits The number of splits to make
     * @returns {Array&lt;Integer>} The evenly-split points on the range
     */
    splitBase(start, range, ringEnd, ringLength, numberOfSplits) {
        const numberOfSplitsInt = Integer.fromInt(numberOfSplits);
        const divider = range.divide(numberOfSplitsInt);
        let remainder = range.modulo(numberOfSplitsInt);

        const results = [];
        let current = start;
        const dividerPlusOne = divider.add(Integer.ONE);

        for (let i = 1; i &lt; numberOfSplits; i++) {
            if (remainder.greaterThan(Integer.ZERO)) {
                current = current.add(dividerPlusOne);
            } else {
                current = current.add(divider);
            }
            if (ringLength &amp;&amp; current.greaterThan(ringEnd)) {
                current = current.subtract(ringLength);
            }
            results.push(current);
            remainder = remainder.subtract(Integer.ONE);
        }
        return results;
    }

    /**
     * Return internal string based representation of a Token.
     * @param {Token} token
     */
    stringify(token) {
        return token.getValue().toString();
    }
}

/**
 * Uniformly distributes data across the cluster based on Cassandra flavored Murmur3 hashed values.
 */
class Murmur3Tokenizer extends Tokenizer {
    constructor() {
        super();
    }

    /**
     * @param {Buffer} value
     * @return {Murmur3Token}
     */
    hash(value) {
        // This is an adapted version of the MurmurHash.hash3_x64_128 from Cassandra used
        // for M3P. Compared to that methods, there's a few inlining of arguments and we
        // only return the first 64-bits of the result since that's all M3 partitioner uses.

        const data = value;
        let offset = 0;
        const length = data.length;

        const nblocks = length >> 4; // Process as 128-bit blocks.

        const h1 = new MutableLong();
        const h2 = new MutableLong();
        // eslint-disable-next-line
        let k1 = new MutableLong();
        // eslint-disable-next-line
        let k2 = new MutableLong();

        for (let i = 0; i &lt; nblocks; i++) {
            k1 = this.getBlock(data, offset, i * 2);
            k2 = this.getBlock(data, offset, i * 2 + 1);

            k1.multiply(mconst1);
            this.rotl64(k1, 31);
            k1.multiply(mconst2);

            h1.xor(k1);
            this.rotl64(h1, 27);
            h1.add(h2);
            h1.multiply(mlongFive).add(mconst5);

            k2.multiply(mconst2);
            this.rotl64(k2, 33);
            k2.multiply(mconst1);
            h2.xor(k2);
            this.rotl64(h2, 31);
            h2.add(h1);
            h2.multiply(mlongFive).add(mconst6);
        }
        // ----------
        // tail

        // Advance offset to the unprocessed tail of the data.
        offset += nblocks * 16;

        k1 = new MutableLong();
        k2 = new MutableLong();

        /* eslint-disable no-fallthrough */
        switch (length &amp; 15) {
            case 15:
                k2.xor(fromSignedByte(data[offset + 14]).shiftLeft(48));
            case 14:
                k2.xor(fromSignedByte(data[offset + 13]).shiftLeft(40));
            case 13:
                k2.xor(fromSignedByte(data[offset + 12]).shiftLeft(32));
            case 12:
                k2.xor(fromSignedByte(data[offset + 11]).shiftLeft(24));
            case 11:
                k2.xor(fromSignedByte(data[offset + 10]).shiftLeft(16));
            case 10:
                k2.xor(fromSignedByte(data[offset + 9]).shiftLeft(8));
            case 9:
                k2.xor(fromSignedByte(data[offset + 8]));
                k2.multiply(mconst2);
                this.rotl64(k2, 33);
                k2.multiply(mconst1);
                h2.xor(k2);
            case 8:
                k1.xor(fromSignedByte(data[offset + 7]).shiftLeft(56));
            case 7:
                k1.xor(fromSignedByte(data[offset + 6]).shiftLeft(48));
            case 6:
                k1.xor(fromSignedByte(data[offset + 5]).shiftLeft(40));
            case 5:
                k1.xor(fromSignedByte(data[offset + 4]).shiftLeft(32));
            case 4:
                k1.xor(fromSignedByte(data[offset + 3]).shiftLeft(24));
            case 3:
                k1.xor(fromSignedByte(data[offset + 2]).shiftLeft(16));
            case 2:
                k1.xor(fromSignedByte(data[offset + 1]).shiftLeft(8));
            case 1:
                k1.xor(fromSignedByte(data[offset]));
                k1.multiply(mconst1);
                this.rotl64(k1, 31);
                k1.multiply(mconst2);
                h1.xor(k1);
        }
        /* eslint-enable no-fallthrough */

        h1.xor(MutableLong.fromNumber(length));
        h2.xor(MutableLong.fromNumber(length));

        h1.add(h2);
        h2.add(h1);

        this.fmix(h1);
        this.fmix(h2);

        h1.add(h2);

        return new token.Murmur3Token(h1);
    }

    /**
     *
     * @param {Array&lt;Number>} key
     * @param {Number} offset
     * @param {Number} index
     * @return {MutableLong}
     */
    getBlock(key, offset, index) {
        const i8 = index &lt;&lt; 3;
        const blockOffset = offset + i8;
        return new MutableLong(
            key[blockOffset] | (key[blockOffset + 1] &lt;&lt; 8),
            key[blockOffset + 2] | (key[blockOffset + 3] &lt;&lt; 8),
            key[blockOffset + 4] | (key[blockOffset + 5] &lt;&lt; 8),
            key[blockOffset + 6] | (key[blockOffset + 7] &lt;&lt; 8),
        );
    }

    /**
     * @param {MutableLong} v
     * @param {Number} n
     */
    rotl64(v, n) {
        const left = v.clone().shiftLeft(n);
        v.shiftRightUnsigned(64 - n).or(left);
    }

    /** @param {MutableLong} k */
    fmix(k) {
        k.xor(
            new MutableLong(
                (k.getUint16(2) >>> 1) | ((k.getUint16(3) &lt;&lt; 15) &amp; 0xffff),
                k.getUint16(3) >>> 1,
                0,
                0,
            ),
        );
        k.multiply(mconst3);
        const other = new MutableLong(
            (k.getUint16(2) >>> 1) | ((k.getUint16(3) &lt;&lt; 15) &amp; 0xffff),
            k.getUint16(3) >>> 1,
            0,
            0,
        );
        k.xor(other);
        k.multiply(mconst4);
        k.xor(
            new MutableLong(
                (k.getUint16(2) >>> 1) | ((k.getUint16(3) &lt;&lt; 15) &amp; 0xffff),
                k.getUint16(3) >>> 1,
                0,
                0,
            ),
        );
    }

    /**
     * Parses a int64 decimal string representation into a MutableLong.
     * @param {String} value
     * @returns {Murmur3Token}
     */
    parse(value) {
        return new token.Murmur3Token(MutableLong.fromString(value));
    }

    minToken() {
        if (!this._minToken) {
            // minimum long value.
            this._minToken = this.parse("-9223372036854775808");
        }
        return this._minToken;
    }

    maxToken() {
        if (!this._maxToken) {
            this._maxToken = this.parse("9223372036854775807");
        }
        return this._maxToken;
    }

    maxValue() {
        if (!this._maxValue) {
            this._maxValue = Integer.fromString("9223372036854775807");
        }
        return this._maxValue;
    }

    minValue() {
        if (!this._minValue) {
            this._minValue = Integer.fromString("-9223372036854775808");
        }
        return this._minValue;
    }

    ringLength() {
        if (!this._ringLength) {
            this._ringLength = this.maxValue().subtract(this.minValue());
        }
        return this._ringLength;
    }

    split(start, end, numberOfSplits) {
        // ]min, min] means the whole ring.
        if (start.equals(end) &amp;&amp; start.equals(this.minToken())) {
            end = this.maxToken();
        }

        const startVal = Integer.fromString(start.getValue().toString());
        const endVal = Integer.fromString(end.getValue().toString());

        let range = endVal.subtract(startVal);
        if (range.isNegative()) {
            range = range.add(this.ringLength());
        }

        const values = this.splitBase(
            startVal,
            range,
            this.maxValue(),
            this.ringLength(),
            numberOfSplits,
        );
        return values.map((v) => this.parse(v.toString()));
    }

    stringify(token) {
        // Get the underlying MutableLong
        const value = token.getValue();
        // We need a way to uniquely represent a token, it doesn't have to be the decimal string representation
        // Using the uint16 avoids divisions and other expensive operations on the longs
        return (
            value.getUint16(0) +
            "," +
            value.getUint16(1) +
            "," +
            value.getUint16(2) +
            "," +
            value.getUint16(3)
        );
    }
}

/**
 * Uniformly distributes data across the cluster based on MD5 hash values.
 */
class RandomTokenizer extends Tokenizer {
    constructor() {
        super();

        this._crypto = require("crypto");
    }

    /**
     * @param {Buffer|Array} value
     * @returns {RandomToken}
     */
    hash(value) {
        if (Array.isArray(value)) {
            value = utils.allocBufferFromArray(value);
        }
        const hashedValue = this._crypto
            .createHash("md5")
            .update(value)
            .digest();
        return new token.RandomToken(Integer.fromBuffer(hashedValue).abs());
    }

    /**
     * @returns {Token}
     */
    parse(value) {
        return new token.RandomToken(Integer.fromString(value));
    }

    minToken() {
        if (!this._minToken) {
            this._minToken = this.parse("-1");
        }
        return this._minToken;
    }

    maxValue() {
        if (!this._maxValue) {
            this._maxValue = Integer.fromNumber(Math.pow(2, 127));
        }
        return this._maxValue;
    }

    maxToken() {
        if (!this._maxToken) {
            this._maxToken = new token.RandomToken(this.maxValue());
        }
        return this._maxToken;
    }

    ringLength() {
        if (!this._ringLength) {
            this._ringLength = this.maxValue().add(Integer.ONE);
        }
        return this._ringLength;
    }

    split(start, end, numberOfSplits) {
        // ]min, min] means the whole ring.
        if (start.equals(end) &amp;&amp; start.equals(this.minToken())) {
            end = this.maxToken();
        }

        const startVal = start.getValue();
        const endVal = end.getValue();

        let range = endVal.subtract(startVal);
        if (range.lessThan(Integer.ZERO)) {
            range = range.add(this.ringLength());
        }

        const values = this.splitBase(
            startVal,
            range,
            this.maxValue(),
            this.ringLength(),
            numberOfSplits,
        );
        return values.map((v) => new token.RandomToken(v));
    }
}

class ByteOrderedTokenizer extends Tokenizer {
    constructor() {
        super();
    }

    /**
     * @param {Buffer} value
     * @returns {ByteOrderedToken}
     */
    hash(value) {
        // strip any trailing zeros as tokens with trailing zeros are equivalent
        // to those who don't have them.
        if (Array.isArray(value)) {
            value = utils.allocBufferFromArray(value);
        }
        let zeroIndex = value.length;
        for (let i = value.length - 1; i > 0; i--) {
            if (value[i] === 0) {
                zeroIndex = i;
            } else {
                break;
            }
        }
        return new token.ByteOrderedToken(value.slice(0, zeroIndex));
    }

    stringify(token) {
        return token.getValue().toString("hex");
    }

    parse(value) {
        return this.hash(utils.allocBufferFromString(value, "hex"));
    }

    minToken() {
        if (!this._minToken) {
            this._minToken = this.hash([]);
        }
        return this._minToken;
    }

    _toNumber(buffer, significantBytes) {
        // Convert a token's byte array to a number in order to perform computations.
        // This depends on the number of significant bytes that is used to normalize all tokens
        // to the same size.  For example if the token is 0x01 but significant bytes is 2, the
        // result is 0x0100.
        let target = buffer;
        if (buffer.length !== significantBytes) {
            target = Buffer.alloc(significantBytes);
            buffer.copy(target);
        }

        // similar to Integer.fromBuffer except we force the sign to 0.
        const bits = new Array(Math.ceil(target.length / 4));
        for (let i = 0; i &lt; bits.length; i++) {
            let offset = target.length - (i + 1) * 4;
            let value;
            if (offset &lt; 0) {
                // The buffer length is not multiple of 4
                offset = offset + 4;
                value = 0;
                for (let j = 0; j &lt; offset; j++) {
                    const byte = target[j];
                    value = value | (byte &lt;&lt; ((offset - j - 1) * 8));
                }
            } else {
                value = target.readInt32BE(offset);
            }
            bits[i] = value;
        }
        return new Integer(bits, 0);
    }

    _toBuffer(number, significantBytes) {
        // Convert numeric representation back to a buffer.
        const buffer = Integer.toBuffer(number);
        if (buffer.length === significantBytes) {
            return buffer;
        }

        // if first byte is a sign byte, skip it.
        let start, length;
        if (buffer[0] === 0) {
            start = 1;
            length = buffer.length - 1;
        } else {
            start = 0;
            length = buffer.length;
        }

        const target = Buffer.alloc(significantBytes);
        buffer.copy(target, significantBytes - length, start, length + start);
        return target;
    }

    split(start, end, numberOfSplits) {
        const tokenOrder = start.compare(end);

        if (tokenOrder === 0 &amp;&amp; start.equals(this.minToken())) {
            throw new Error("Cannot split whole ring with ordered partitioner");
        }

        let startVal, endVal, range, ringLength, ringEnd;
        const intNumberOfSplits = Integer.fromNumber(numberOfSplits);
        // Since tokens are compared lexicographically, convert to numbers using the
        // largest length (i.e. given 0x0A and 0x0BCD, switch to 0x0A00 and 0x0BCD)
        let significantBytes = Math.max(
            start.getValue().length,
            end.getValue().length,
        );
        if (tokenOrder &lt; 0) {
            let addedBytes = 0;
            while (true) {
                startVal = this._toNumber(start.getValue(), significantBytes);
                endVal = this._toNumber(end.getValue(), significantBytes);
                range = endVal.subtract(startVal);
                if (addedBytes === 4 || range.compare(intNumberOfSplits) >= 0) {
                    break;
                }
                significantBytes += 1;
                addedBytes += 1;
            }
        } else {
            let addedBytes = 0;
            while (true) {
                startVal = this._toNumber(start.getValue(), significantBytes);
                endVal = this._toNumber(end.getValue(), significantBytes);
                ringLength = Integer.fromNumber(
                    Math.pow(2, significantBytes * 8),
                );
                ringEnd = ringLength.subtract(Integer.ONE);
                range = endVal.subtract(startVal).add(ringLength);
                if (addedBytes === 4 || range.compare(intNumberOfSplits) >= 0) {
                    break;
                }
                significantBytes += 1;
                addedBytes += 1;
            }
        }

        const values = this.splitBase(
            startVal,
            range,
            ringEnd,
            ringLength,
            numberOfSplits,
        );
        return values.map(
            (v) =>
                new token.ByteOrderedToken(this._toBuffer(v, significantBytes)),
        );
    }
}

/**
 * @param {Number} value
 * @return {MutableLong}
 */
function fromSignedByte(value) {
    if (value &lt; 128) {
        return new MutableLong(value, 0, 0, 0);
    }
    return new MutableLong((value - 256) &amp; 0xffff, 0xffff, 0xffff, 0xffff);
}

exports.Murmur3Tokenizer = Murmur3Tokenizer;
exports.RandomTokenizer = RandomTokenizer;
exports.ByteOrderedTokenizer = ByteOrderedTokenizer;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-auth.html">auth</a></li><li><a href="module-concurrent.html">concurrent</a></li><li><a href="module-datastax.html">datastax</a></li><li><a href="module-errors.html">errors</a></li><li><a href="module-geometry.html">geometry</a></li><li><a href="module-mapping.html">mapping</a></li><li><a href="module-metadata.html">metadata</a></li><li><a href="module-metrics.html">metrics</a></li><li><a href="module-policies.html">policies</a></li><li><a href="module-policies_addressResolution.html">policies/addressResolution</a></li><li><a href="module-policies_loadBalancing.html">policies/loadBalancing</a></li><li><a href="module-policies_reconnection.html">policies/reconnection</a></li><li><a href="module-policies_retry.html">policies/retry</a></li><li><a href="module-policies_speculativeExecution.html">policies/speculativeExecution</a></li><li><a href="module-policies_timestampGeneration.html">policies/timestampGeneration</a></li><li><a href="module-tracker.html">tracker</a></li><li><a href="module-types.html">types</a></li></ul><h3>Classes</h3><ul><li><a href="AddressResolver.html">AddressResolver</a></li><li><a href="AuthResponseRequest.html">AuthResponseRequest</a></li><li><a href="BatchRequest.html">BatchRequest</a></li><li><a href="ByteOrderedToken.html">ByteOrderedToken</a></li><li><a href="Client.html">Client</a></li><li><a href="Connection.html">Connection</a></li><li><a href="ControlConnection.html">ControlConnection</a></li><li><a href="CredentialsRequest.html">CredentialsRequest</a></li><li><a href="Encoder.html">Encoder</a></li><li><a href="ExecuteRequest.html">ExecuteRequest</a></li><li><a href="ExecutionOptions.html">ExecutionOptions</a></li><li><a href="ExecutionProfile.html">ExecutionProfile</a></li><li><a href="FrameReader.html">FrameReader</a></li><li><a href="FrameWriter.html">FrameWriter</a></li><li><a href="HashSet.html">HashSet</a></li><li><a href="Host.html">Host</a></li><li><a href="HostConnectionPool.html">HostConnectionPool</a></li><li><a href="HostMap.html">HostMap</a></li><li><a href="InsightsClient.html">InsightsClient</a></li><li><a href="LineString.html">LineString</a></li><li><a href="Murmur3Token.html">Murmur3Token</a></li><li><a href="Murmur3Tokenizer.html">Murmur3Tokenizer</a></li><li><a href="OperationState.html">OperationState</a></li><li><a href="Point.html">Point</a></li><li><a href="Polygon.html">Polygon</a></li><li><a href="PrepareHandler.html">PrepareHandler</a></li><li><a href="QueryRequest.html">QueryRequest</a></li><li><a href="RandomToken.html">RandomToken</a></li><li><a href="RandomTokenizer.html">RandomTokenizer</a></li><li><a href="Request.html">Request</a></li><li><a href="RequestExecution.html">RequestExecution</a></li><li><a href="RequestHandler.html">RequestHandler</a></li><li><a href="StartupRequest.html">StartupRequest</a></li><li><a href="StreamIdStack.html">StreamIdStack</a></li><li><a href="Token.html">Token</a></li><li><a href="TokenRange.html">TokenRange</a></li><li><a href="Tokenizer.html">Tokenizer</a></li><li><a href="TransitionalModePlainTextAuthenticator.html">TransitionalModePlainTextAuthenticator</a></li><li><a href="WriteQueue.html">WriteQueue</a></li><li><a href="module-auth-AuthProvider.html">AuthProvider</a></li><li><a href="module-auth-Authenticator.html">Authenticator</a></li><li><a href="module-auth-PlainTextAuthProvider.html">PlainTextAuthProvider</a></li><li><a href="module-errors-ArgumentError.html">ArgumentError</a></li><li><a href="module-errors-AuthenticationError.html">AuthenticationError</a></li><li><a href="module-errors-BusyConnectionError.html">BusyConnectionError</a></li><li><a href="module-errors-DriverInternalError.html">DriverInternalError</a></li><li><a href="module-errors-NoHostAvailableError.html">NoHostAvailableError</a></li><li><a href="module-errors-NotSupportedError.html">NotSupportedError</a></li><li><a href="module-errors-OperationTimedOutError.html">OperationTimedOutError</a></li><li><a href="module-errors-ResponseError.html">ResponseError</a></li><li><a href="module-mapping-DefaultTableMappings.html">DefaultTableMappings</a></li><li><a href="module-mapping-Mapper.html">Mapper</a></li><li><a href="module-mapping-ModelBatchItem.html">ModelBatchItem</a></li><li><a href="module-mapping-ModelMapper.html">ModelMapper</a></li><li><a href="module-mapping-Result.html">Result</a></li><li><a href="module-mapping-UnderscoreCqlToCamelCaseMappings.html">UnderscoreCqlToCamelCaseMappings</a></li><li><a href="module-metadata-Aggregate.html">Aggregate</a></li><li><a href="module-metadata-ClientState.html">ClientState</a></li><li><a href="module-metadata-DataCollection.html">DataCollection</a></li><li><a href="module-metadata-Index.html">Index</a></li><li><a href="module-metadata-MaterializedView.html">MaterializedView</a></li><li><a href="module-metadata-Metadata.html">Metadata</a></li><li><a href="module-metadata-SchemaFunction.html">SchemaFunction</a></li><li><a href="module-metadata-TableMetadata.html">TableMetadata</a></li><li><a href="module-metrics-DefaultMetrics.html">DefaultMetrics</a></li><li><a href="module-policies_addressResolution-AddressTranslator.html">AddressTranslator</a></li><li><a href="module-policies_addressResolution-EC2MultiRegionTranslator.html">EC2MultiRegionTranslator</a></li><li><a href="module-policies_loadBalancing-AllowListPolicy.html">AllowListPolicy</a></li><li><a href="module-policies_loadBalancing-DCAwareRoundRobinPolicy.html">DCAwareRoundRobinPolicy</a></li><li><a href="module-policies_loadBalancing-DefaultLoadBalancingPolicy.html">DefaultLoadBalancingPolicy</a></li><li><a href="module-policies_loadBalancing-LoadBalancingPolicy.html">LoadBalancingPolicy</a></li><li><a href="module-policies_loadBalancing-RoundRobinPolicy.html">RoundRobinPolicy</a></li><li><a href="module-policies_loadBalancing-TokenAwarePolicy.html">TokenAwarePolicy</a></li><li><a href="module-policies_loadBalancing-WhiteListPolicy.html">WhiteListPolicy</a></li><li><a href="module-policies_reconnection-ConstantReconnectionPolicy.html">ConstantReconnectionPolicy</a></li><li><a href="module-policies_reconnection-ExponentialReconnectionPolicy.html">ExponentialReconnectionPolicy</a></li><li><a href="module-policies_reconnection-ReconnectionPolicy.html">ReconnectionPolicy</a></li><li><a href="module-policies_retry-FallthroughRetryPolicy.html">FallthroughRetryPolicy</a></li><li><a href="module-policies_retry-IdempotenceAwareRetryPolicy.html">IdempotenceAwareRetryPolicy</a></li><li><a href="module-policies_retry-RetryPolicy.html">RetryPolicy</a></li><li><a href="module-policies_speculativeExecution-ConstantSpeculativeExecutionPolicy.html">ConstantSpeculativeExecutionPolicy</a></li><li><a href="module-policies_speculativeExecution-NoSpeculativeExecutionPolicy.html">NoSpeculativeExecutionPolicy</a></li><li><a href="module-policies_speculativeExecution-SpeculativeExecutionPolicy.html">SpeculativeExecutionPolicy</a></li><li><a href="module-policies_timestampGeneration-MonotonicTimestampGenerator.html">MonotonicTimestampGenerator</a></li><li><a href="module-policies_timestampGeneration-TimestampGenerator.html">TimestampGenerator</a></li><li><a href="module-tracker-RequestLogger.html">RequestLogger</a></li><li><a href="module-types-BigDecimal.html">BigDecimal</a></li><li><a href="module-types-Duration.html">Duration</a></li><li><a href="module-types-InetAddress.html">InetAddress</a></li><li><a href="module-types-Integer.html">Integer</a></li><li><a href="module-types-LocalDate.html">LocalDate</a></li><li><a href="module-types-LocalTime.html">LocalTime</a></li><li><a href="module-types-Long.html">Long</a></li><li><a href="module-types-ResultSet.html">ResultSet</a></li><li><a href="module-types-ResultStream.html">ResultStream</a></li><li><a href="module-types-Row.html">Row</a></li><li><a href="module-types-TimeUuid.html">TimeUuid</a></li><li><a href="module-types-Tuple.html">Tuple</a></li><li><a href="module-types-Uuid.html">Uuid</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-mapping-TableMappings.html">TableMappings</a></li><li><a href="module-metrics-ClientMetrics.html">ClientMetrics</a></li><li><a href="module-tracker-RequestTracker.html">RequestTracker</a></li></ul><h3>Events</h3><ul><li><a href="Client.html#event:hostAdd">hostAdd</a></li><li><a href="Client.html#event:hostDown">hostDown</a></li><li><a href="Client.html#event:hostRemove">hostRemove</a></li><li><a href="Client.html#event:hostUp">hostUp</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Parser">Parser</a></li><li><a href="global.html#Protocol">Protocol</a></li><li><a href="global.html#ResultEmitter">ResultEmitter</a></li><li><a href="global.html#adaptNamedParamsPrepared">adaptNamedParamsPrepared</a></li><li><a href="global.html#adaptNamedParamsWithHints">adaptNamedParamsWithHints</a></li><li><a href="global.html#allocBuffer">allocBuffer</a></li><li><a href="global.html#allocBufferFromArray">allocBufferFromArray</a></li><li><a href="global.html#allocBufferFromString">allocBufferFromString</a></li><li><a href="global.html#allocBufferUnsafe">allocBufferUnsafe</a></li><li><a href="global.html#arrayIterator">arrayIterator</a></li><li><a href="global.html#binarySearch">binarySearch</a></li><li><a href="global.html#callbackOnce">callbackOnce</a></li><li><a href="global.html#copyBuffer">copyBuffer</a></li><li><a href="global.html#coreConnectionsPerHostV2">coreConnectionsPerHostV2</a></li><li><a href="global.html#coreConnectionsPerHostV3">coreConnectionsPerHostV3</a></li><li><a href="global.html#deepExtend">deepExtend</a></li><li><a href="global.html#defaultOptions">defaultOptions</a></li><li><a href="global.html#defaultPromiseFactory">defaultPromiseFactory</a></li><li><a href="global.html#defaultReleaseDelay">defaultReleaseDelay</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#each">each</a></li><li><a href="global.html#eachSeries">eachSeries</a></li><li><a href="global.html#emptyArray">emptyArray</a></li><li><a href="global.html#emptyObject">emptyObject</a></li><li><a href="global.html#encodeVector">encodeVector</a></li><li><a href="global.html#errorCodes">errorCodes</a></li><li><a href="global.html#extend">extend</a></li><li><a href="global.html#fixStack">fixStack</a></li><li><a href="global.html#forEachOf">forEachOf</a></li><li><a href="global.html#fromCallback">fromCallback</a></li><li><a href="global.html#fromEvent">fromEvent</a></li><li><a href="global.html#fromSignedByte">fromSignedByte</a></li><li><a href="global.html#getCallback">getCallback</a></li><li><a href="global.html#getDefaultOptions">getDefaultOptions</a></li><li><a href="global.html#groupSize">groupSize</a></li><li><a href="global.html#ifUndefined">ifUndefined</a></li><li><a href="global.html#ifUndefined3">ifUndefined3</a></li><li><a href="global.html#insertSorted">insertSorted</a></li><li><a href="global.html#iteratorToArray">iteratorToArray</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#mapSeries">mapSeries</a></li><li><a href="global.html#maxGroupsFor2Bytes">maxGroupsFor2Bytes</a></li><li><a href="global.html#maxInt">maxInt</a></li><li><a href="global.html#maxRequestsPerConnectionV2">maxRequestsPerConnectionV2</a></li><li><a href="global.html#maxRequestsPerConnectionV3">maxRequestsPerConnectionV3</a></li><li><a href="global.html#newQueryPlan">newQueryPlan</a></li><li><a href="global.html#objectValues">objectValues</a></li><li><a href="global.html#optionalCallback">optionalCallback</a></li><li><a href="global.html#parallel">parallel</a></li><li><a href="global.html#parseVectorTypeArgs">parseVectorTypeArgs</a></li><li><a href="global.html#promiseWrapper">promiseWrapper</a></li><li><a href="global.html#releasableSize">releasableSize</a></li><li><a href="global.html#resultFlag">resultFlag</a></li><li><a href="global.html#rowBuffer">rowBuffer</a></li><li><a href="global.html#series">series</a></li><li><a href="global.html#setMetadataDependent">setMetadataDependent</a></li><li><a href="global.html#shiftToGroup">shiftToGroup</a></li><li><a href="global.html#stringRepeat">stringRepeat</a></li><li><a href="global.html#throwNotSupported">throwNotSupported</a></li><li><a href="global.html#times">times</a></li><li><a href="global.html#timesLimit">timesLimit</a></li><li><a href="global.html#timesSeries">timesSeries</a></li><li><a href="global.html#toBackground">toBackground</a></li><li><a href="global.html#toCallback">toCallback</a></li><li><a href="global.html#toLowerCaseProperties">toLowerCaseProperties</a></li><li><a href="global.html#totalLength">totalLength</a></li><li><a href="global.html#validateFn">validateFn</a></li><li><a href="global.html#whilst">whilst</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Nov 27 2024 09:28:44 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
